
#import <Foundation/Foundation.h>

@interface MassiveEmergencyData : NSObject

@end

@implementation MassiveEmergencyData

//: Need to move: %.2f, will be moving %@
+ (NSString *)k_activityPreference {
    /* static */ NSString *k_activityPreference = nil;
    if (!k_activityPreference) {
		NSArray<NSString *> *origin = @[@"37", @"9", @"41", @"255", @"243", @"125", @"194", @"141", @"25", @"64", @"37", @"32", @"103", @"110", @"105", @"118", @"111", @"109", @"32", @"101", @"98", @"32", @"108", @"108", @"105", @"119", @"32", @"44", @"102", @"50", @"46", @"37", @"32", @"58", @"101", @"118", @"111", @"109", @"32", @"111", @"116", @"32", @"100", @"101", @"101", @"78", @"22"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        k_activityPreference = [self StringFromMassiveEmergencyData:value];
    }
    return k_activityPreference;
}

//: Already Disabled
+ (NSString *)themeLateDelicateFormat {
    /* static */ NSString *themeLateDelicateFormat = nil;
    if (!themeLateDelicateFormat) {
		NSArray<NSString *> *origin = @[@"16", @"10", @"172", @"199", @"203", @"216", @"193", @"1", @"142", @"96", @"100", @"101", @"108", @"98", @"97", @"115", @"105", @"68", @"32", @"121", @"100", @"97", @"101", @"114", @"108", @"65", @"115"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        themeLateDelicateFormat = [self StringFromMassiveEmergencyData:value];
    }
    return themeLateDelicateFormat;
}

//: keyboardDistanceFromTextField: %.2f
+ (NSString *)screenProceedMartId {
    /* static */ NSString *screenProceedMartId = nil;
    if (!screenProceedMartId) {
		NSArray<NSString *> *origin = @[@"35", @"2", @"102", @"50", @"46", @"37", @"32", @"58", @"100", @"108", @"101", @"105", @"70", @"116", @"120", @"101", @"84", @"109", @"111", @"114", @"70", @"101", @"99", @"110", @"97", @"116", @"115", @"105", @"68", @"100", @"114", @"97", @"111", @"98", @"121", @"101", @"107", @"49"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        screenProceedMartId = [self StringFromMassiveEmergencyData:value];
    }
    return screenProceedMartId;
}  

//: up
+ (NSString *)coreResolveTidePath {
    /* static */ NSString *coreResolveTidePath = nil;
    if (!coreResolveTidePath) {
		NSArray<NSString *> *origin = @[@"2", @"11", @"93", @"131", @"35", @"130", @"218", @"62", @"145", @"37", @"235", @"112", @"117", @"210"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        coreResolveTidePath = [self StringFromMassiveEmergencyData:value];
    }
    return coreResolveTidePath;
}

//: Adjusting %.2f to %@ ContentOffset
+ (NSString *)kHeadquarterDevice {
    /* static */ NSString *kHeadquarterDevice = nil;
    if (!kHeadquarterDevice) {
		NSArray<NSString *> *origin = @[@"34", @"9", @"111", @"30", @"71", @"161", @"231", @"105", @"81", @"116", @"101", @"115", @"102", @"102", @"79", @"116", @"110", @"101", @"116", @"110", @"111", @"67", @"32", @"64", @"37", @"32", @"111", @"116", @"32", @"102", @"50", @"46", @"37", @"32", @"103", @"110", @"105", @"116", @"115", @"117", @"106", @"100", @"65", @"113"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        kHeadquarterDevice = [self StringFromMassiveEmergencyData:value];
    }
    return kHeadquarterDevice;
}

//: Found %lu responder sibling(s)
+ (NSString *)widgetEstimatePage {
    /* static */ NSString *widgetEstimatePage = nil;
    if (!widgetEstimatePage) {
		NSArray<NSString *> *origin = @[@"30", @"5", @"49", @"11", @"130", @"41", @"115", @"40", @"103", @"110", @"105", @"108", @"98", @"105", @"115", @"32", @"114", @"101", @"100", @"110", @"111", @"112", @"115", @"101", @"114", @"32", @"117", @"108", @"37", @"32", @"100", @"110", @"117", @"111", @"70", @"89"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        widgetEstimatePage = [self StringFromMassiveEmergencyData:value];
    }
    return widgetEstimatePage;
}

//: Enabled
+ (NSString *)styleAluminumDevice {
    /* static */ NSString *styleAluminumDevice = nil;
    if (!styleAluminumDevice) {
		NSArray<NSString *> *origin = @[@"7", @"8", @"247", @"152", @"195", @"62", @"116", @"218", @"100", @"101", @"108", @"98", @"97", @"110", @"69", @"104"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        styleAluminumDevice = [self StringFromMassiveEmergencyData:value];
    }
    return styleAluminumDevice;
}

//: Refuses to become first responder: %@
+ (NSString *)coreCurateError {
    /* static */ NSString *coreCurateError = nil;
    if (!coreCurateError) {
		NSArray<NSString *> *origin = @[@"37", @"6", @"121", @"30", @"39", @"13", @"64", @"37", @"32", @"58", @"114", @"101", @"100", @"110", @"111", @"112", @"115", @"101", @"114", @"32", @"116", @"115", @"114", @"105", @"102", @"32", @"101", @"109", @"111", @"99", @"101", @"98", @"32", @"111", @"116", @"32", @"115", @"101", @"115", @"117", @"102", @"101", @"82", @"8"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        coreCurateError = [self StringFromMassiveEmergencyData:value];
    }
    return coreCurateError;
}

//: Already Enabled
+ (NSString *)layoutGovernPage {
    /* static */ NSString *layoutGovernPage = nil;
    if (!layoutGovernPage) {
		NSArray<NSString *> *origin = @[@"15", @"11", @"99", @"51", @"215", @"95", @"183", @"25", @"184", @"120", @"153", @"100", @"101", @"108", @"98", @"97", @"110", @"69", @"32", @"121", @"100", @"97", @"101", @"114", @"108", @"65", @"205"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        layoutGovernPage = [self StringFromMassiveEmergencyData:value];
    }
    return layoutGovernPage;
}

//: shouldResignOnTouchOutside: %@
+ (NSString *)themeTumManSettings {
    /* static */ NSString *themeTumManSettings = nil;
    if (!themeTumManSettings) {
		NSArray<NSString *> *origin = @[@"30", @"3", @"122", @"64", @"37", @"32", @"58", @"101", @"100", @"105", @"115", @"116", @"117", @"79", @"104", @"99", @"117", @"111", @"84", @"110", @"79", @"110", @"103", @"105", @"115", @"101", @"82", @"100", @"108", @"117", @"111", @"104", @"115", @"143"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        themeTumManSettings = [self StringFromMassiveEmergencyData:value];
    }
    return themeTumManSettings;
}

//: Yes
+ (NSString *)themeBoostPath {
    /* static */ NSString *themeBoostPath = nil;
    if (!themeBoostPath) {
		NSArray<NSString *> *origin = @[@"3", @"4", @"146", @"224", @"115", @"101", @"89", @"208"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        themeBoostPath = [self StringFromMassiveEmergencyData:value];
    }
    return themeBoostPath;
}

//: old ContentInset : %@ new ContentInset : %@
+ (NSString *)commonDragFormat {
    /* static */ NSString *commonDragFormat = nil;
    if (!commonDragFormat) {
		NSArray<NSString *> *origin = @[@"43", @"11", @"43", @"125", @"89", @"100", @"169", @"40", @"143", @"255", @"94", @"64", @"37", @"32", @"58", @"32", @"116", @"101", @"115", @"110", @"73", @"116", @"110", @"101", @"116", @"110", @"111", @"67", @"32", @"119", @"101", @"110", @"32", @"64", @"37", @"32", @"58", @"32", @"116", @"101", @"115", @"110", @"73", @"116", @"110", @"101", @"116", @"110", @"111", @"67", @"32", @"100", @"108", @"111", @"102"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        commonDragFormat = [self StringFromMassiveEmergencyData:value];
    }
    return commonDragFormat;
}

//: No
+ (NSString *)appRuleConfig {
    /* static */ NSString *appRuleConfig = nil;
    if (!appRuleConfig) {
		NSArray<NSString *> *origin = @[@"2", @"5", @"171", @"205", @"65", @"111", @"78", @"172"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        appRuleConfig = [self StringFromMassiveEmergencyData:value];
    }
    return appRuleConfig;
}

//: Set %@ origin to : %@
+ (NSString *)styleBoostId {
    /* static */ NSString *styleBoostId = nil;
    if (!styleBoostId) {
		NSArray<NSString *> *origin = @[@"21", @"8", @"54", @"207", @"150", @"247", @"65", @"168", @"64", @"37", @"32", @"58", @"32", @"111", @"116", @"32", @"110", @"105", @"103", @"105", @"114", @"111", @"32", @"64", @"37", @"32", @"116", @"101", @"83", @"168"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        styleBoostId = [self StringFromMassiveEmergencyData:value];
    }
    return styleBoostId;
}

//: TextFieldViewController
+ (NSString *)widgetHoldValue {
    /* static */ NSString *widgetHoldValue = nil;
    if (!widgetHoldValue) {
		NSArray<NSString *> *origin = @[@"23", @"12", @"21", @"67", @"24", @"93", @"222", @"8", @"137", @"255", @"118", @"84", @"114", @"101", @"108", @"108", @"111", @"114", @"116", @"110", @"111", @"67", @"119", @"101", @"105", @"86", @"100", @"108", @"101", @"105", @"70", @"116", @"120", @"101", @"84", @"205"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        widgetHoldValue = [self StringFromMassiveEmergencyData:value];
    }
    return widgetHoldValue;
}

//: Restoring contentOffset to : %@
+ (NSString *)themeIdentifyId {
    /* static */ NSString *themeIdentifyId = nil;
    if (!themeIdentifyId) {
		NSArray<NSString *> *origin = @[@"31", @"12", @"221", @"23", @"50", @"210", @"13", @"151", @"126", @"52", @"13", @"51", @"64", @"37", @"32", @"58", @"32", @"111", @"116", @"32", @"116", @"101", @"115", @"102", @"102", @"79", @"116", @"110", @"101", @"116", @"110", @"111", @"99", @"32", @"103", @"110", @"105", @"114", @"111", @"116", @"115", @"101", @"82", @"139"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        themeIdentifyId = [self StringFromMassiveEmergencyData:value];
    }
    return themeIdentifyId;
}

+ (Byte *)MassiveEmergencyDataToCache:(Byte *)data {
    int defendantApart = data[0];
    int governPositive = data[1];
    for (int i = 0; i < defendantApart / 2; i++) {
        int begin = governPositive + i;
        int end = governPositive + defendantApart - i - 1;
        Byte temp = data[begin];
        data[begin] = data[end];
        data[end] = temp;
    }
    data[governPositive + defendantApart] = 0;
    return data + governPositive;
}

//: Restoring ScrollView contentInset to : %@
+ (NSString *)themeGiNearlyTimer {
    /* static */ NSString *themeGiNearlyTimer = nil;
    if (!themeGiNearlyTimer) {
		NSArray<NSString *> *origin = @[@"41", @"8", @"207", @"4", @"73", @"99", @"35", @"52", @"64", @"37", @"32", @"58", @"32", @"111", @"116", @"32", @"116", @"101", @"115", @"110", @"73", @"116", @"110", @"101", @"116", @"110", @"111", @"99", @"32", @"119", @"101", @"105", @"86", @"108", @"108", @"111", @"114", @"99", @"83", @"32", @"103", @"110", @"105", @"114", @"111", @"116", @"115", @"101", @"82", @"126"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        themeGiNearlyTimer = [self StringFromMassiveEmergencyData:value];
    }
    return themeGiNearlyTimer;
}

//: <<<<< %@ ended: %g seconds <<<<<
+ (NSString *)styleWayPlatform {
    /* static */ NSString *styleWayPlatform = nil;
    if (!styleWayPlatform) {
		NSArray<NSString *> *origin = @[@"32", @"12", @"184", @"223", @"49", @"129", @"166", @"58", @"54", @"12", @"120", @"145", @"60", @"60", @"60", @"60", @"60", @"32", @"115", @"100", @"110", @"111", @"99", @"101", @"115", @"32", @"103", @"37", @"32", @"58", @"100", @"101", @"100", @"110", @"101", @"32", @"64", @"37", @"32", @"60", @"60", @"60", @"60", @"60", @"5"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        styleWayPlatform = [self StringFromMassiveEmergencyData:value];
    }
    return styleWayPlatform;
}

//: Refuses to Resign first responder: %@
+ (NSString *)viewKeepId {
    /* static */ NSString *viewKeepId = nil;
    if (!viewKeepId) {
		NSArray<NSString *> *origin = @[@"37", @"11", @"20", @"23", @"53", @"43", @"99", @"235", @"187", @"200", @"199", @"64", @"37", @"32", @"58", @"114", @"101", @"100", @"110", @"111", @"112", @"115", @"101", @"114", @"32", @"116", @"115", @"114", @"105", @"102", @"32", @"110", @"103", @"105", @"115", @"101", @"82", @"32", @"111", @"116", @"32", @"115", @"101", @"115", @"117", @"102", @"101", @"82", @"255"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        viewKeepId = [self StringFromMassiveEmergencyData:value];
    }
    return viewKeepId;
}

//: Previous
+ (NSString *)kTurnKey {
    /* static */ NSString *kTurnKey = nil;
    if (!kTurnKey) {
		NSArray<NSString *> *origin = @[@"8", @"6", @"16", @"63", @"253", @"40", @"115", @"117", @"111", @"105", @"118", @"101", @"114", @"80", @"254"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        kTurnKey = [self StringFromMassiveEmergencyData:value];
    }
    return kTurnKey;
}

//: Next
+ (NSString *)spacingLeasedId {
    /* static */ NSString *spacingLeasedId = nil;
    if (!spacingLeasedId) {
		NSArray<NSString *> *origin = @[@"4", @"3", @"213", @"116", @"120", @"101", @"78", @"70"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        spacingLeasedId = [self StringFromMassiveEmergencyData:value];
    }
    return spacingLeasedId;
}

//: Remaining Move: %.2f
+ (NSString *)styleFlueArrivalError {
    /* static */ NSString *styleFlueArrivalError = nil;
    if (!styleFlueArrivalError) {
		NSArray<NSString *> *origin = @[@"20", @"9", @"188", @"33", @"107", @"37", @"220", @"209", @"94", @"102", @"50", @"46", @"37", @"32", @"58", @"101", @"118", @"111", @"77", @"32", @"103", @"110", @"105", @"110", @"105", @"97", @"109", @"101", @"82", @"58"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        styleFlueArrivalError = [self StringFromMassiveEmergencyData:value];
    }
    return styleFlueArrivalError;
}

//: Saving contentInset: %@ and contentOffset : %@
+ (NSString *)coreJournalismSettings {
    /* static */ NSString *coreJournalismSettings = nil;
    if (!coreJournalismSettings) {
		NSArray<NSString *> *origin = @[@"46", @"5", @"165", @"68", @"191", @"64", @"37", @"32", @"58", @"32", @"116", @"101", @"115", @"102", @"102", @"79", @"116", @"110", @"101", @"116", @"110", @"111", @"99", @"32", @"100", @"110", @"97", @"32", @"64", @"37", @"32", @"58", @"116", @"101", @"115", @"110", @"73", @"116", @"110", @"101", @"116", @"110", @"111", @"99", @"32", @"103", @"110", @"105", @"118", @"97", @"83", @"120"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        coreJournalismSettings = [self StringFromMassiveEmergencyData:value];
    }
    return coreJournalismSettings;
}

//: Done
+ (NSString *)moduleHoldPlatform {
    /* static */ NSString *moduleHoldPlatform = nil;
    if (!moduleHoldPlatform) {
		NSArray<NSString *> *origin = @[@"4", @"11", @"75", @"102", @"91", @"221", @"127", @"126", @"193", @"140", @"183", @"101", @"110", @"111", @"68", @"228"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        moduleHoldPlatform = [self StringFromMassiveEmergencyData:value];
    }
    return moduleHoldPlatform;
}

//: Notification Object: %@
+ (NSString *)commonTradeValue {
    /* static */ NSString *commonTradeValue = nil;
    if (!commonTradeValue) {
		NSArray<NSString *> *origin = @[@"23", @"7", @"5", @"97", @"56", @"231", @"112", @"64", @"37", @"32", @"58", @"116", @"99", @"101", @"106", @"98", @"79", @"32", @"110", @"111", @"105", @"116", @"97", @"99", @"105", @"102", @"105", @"116", @"111", @"78", @"37"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        commonTradeValue = [self StringFromMassiveEmergencyData:value];
    }
    return commonTradeValue;
}

//: Restoring textView.contentInset to : %@
+ (NSString *)featureFreshSoftwareMessage {
    /* static */ NSString *featureFreshSoftwareMessage = nil;
    if (!featureFreshSoftwareMessage) {
		NSArray<NSString *> *origin = @[@"39", @"12", @"70", @"225", @"216", @"170", @"53", @"136", @"158", @"142", @"143", @"235", @"64", @"37", @"32", @"58", @"32", @"111", @"116", @"32", @"116", @"101", @"115", @"110", @"73", @"116", @"110", @"101", @"116", @"110", @"111", @"99", @"46", @"119", @"101", @"105", @"86", @"116", @"120", @"101", @"116", @"32", @"103", @"110", @"105", @"114", @"111", @"116", @"115", @"101", @"82", @"230"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        featureFreshSoftwareMessage = [self StringFromMassiveEmergencyData:value];
    }
    return featureFreshSoftwareMessage;
}

//: Restoring %@ origin to : %@
+ (NSString *)featureRoveConfig {
    /* static */ NSString *featureRoveConfig = nil;
    if (!featureRoveConfig) {
		NSArray<NSString *> *origin = @[@"27", @"8", @"174", @"65", @"145", @"198", @"36", @"133", @"64", @"37", @"32", @"58", @"32", @"111", @"116", @"32", @"110", @"105", @"103", @"105", @"114", @"111", @"32", @"64", @"37", @"32", @"103", @"110", @"105", @"114", @"111", @"116", @"115", @"101", @"82", @"154"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        featureRoveConfig = [self StringFromMassiveEmergencyData:value];
    }
    return featureRoveConfig;
}

//: Old UITextView.contentInset : %@ New UITextView.contentInset : %@
+ (NSString *)themeGutDefensiveContent {
    /* static */ NSString *themeGutDefensiveContent = nil;
    if (!themeGutDefensiveContent) {
		NSArray<NSString *> *origin = @[@"65", @"9", @"27", @"251", @"46", @"227", @"169", @"252", @"5", @"64", @"37", @"32", @"58", @"32", @"116", @"101", @"115", @"110", @"73", @"116", @"110", @"101", @"116", @"110", @"111", @"99", @"46", @"119", @"101", @"105", @"86", @"116", @"120", @"101", @"84", @"73", @"85", @"32", @"119", @"101", @"78", @"32", @"64", @"37", @"32", @"58", @"32", @"116", @"101", @"115", @"110", @"73", @"116", @"110", @"101", @"116", @"110", @"111", @"99", @"46", @"119", @"101", @"105", @"86", @"116", @"120", @"101", @"84", @"73", @"85", @"32", @"100", @"108", @"79", @"232"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        themeGutDefensiveContent = [self StringFromMassiveEmergencyData:value];
    }
    return themeGutDefensiveContent;
}

+ (NSString *)StringFromMassiveEmergencyData:(Byte *)data {
    return [NSString stringWithUTF8String:(char *)[self MassiveEmergencyDataToCache:data]];
}

//: >>>>> %@ started >>>>>
+ (NSString *)componentPublisherPlatform {
    /* static */ NSString *componentPublisherPlatform = nil;
    if (!componentPublisherPlatform) {
		NSArray<NSString *> *origin = @[@"22", @"4", @"254", @"105", @"62", @"62", @"62", @"62", @"62", @"32", @"100", @"101", @"116", @"114", @"97", @"116", @"115", @"32", @"64", @"37", @"32", @"62", @"62", @"62", @"62", @"62", @"41"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        componentPublisherPlatform = [self StringFromMassiveEmergencyData:value];
    }
    return componentPublisherPlatform;
}

//: Saving %@ beginning origin: %@
+ (NSString *)spacingMeaningfulEvent {
    /* static */ NSString *spacingMeaningfulEvent = nil;
    if (!spacingMeaningfulEvent) {
		NSArray<NSString *> *origin = @[@"30", @"7", @"140", @"82", @"248", @"19", @"77", @"64", @"37", @"32", @"58", @"110", @"105", @"103", @"105", @"114", @"111", @"32", @"103", @"110", @"105", @"110", @"110", @"105", @"103", @"101", @"98", @"32", @"64", @"37", @"32", @"103", @"110", @"105", @"118", @"97", @"83", @"103"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        spacingMeaningfulEvent = [self StringFromMassiveEmergencyData:value];
    }
    return spacingMeaningfulEvent;
}

//: Disabled
+ (NSString *)appKindSettings {
    /* static */ NSString *appKindSettings = nil;
    if (!appKindSettings) {
		NSArray<NSString *> *origin = @[@"8", @"3", @"228", @"100", @"101", @"108", @"98", @"97", @"115", @"105", @"68", @"225"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        appKindSettings = [self StringFromMassiveEmergencyData:value];
    }
    return appKindSettings;
}

+ (NSData *)MassiveEmergencyDataToData:(NSArray<NSString *> *)value {
    NSMutableArray<NSString *> *array = [NSMutableArray arrayWithArray:value];
    NSInteger length = array.count;
    Byte *buffer = (Byte *)malloc(length + 1);
    for (int i = 0; i < length; i++) {
        buffer[i] = [array[i] intValue];
    }
    buffer[length] = 0;
    return [NSData dataWithBytesNoCopy:buffer length:length freeWhenDone:YES];
}

//: Moving Upward
+ (NSString *)viewSegmentEvent {
    /* static */ NSString *viewSegmentEvent = nil;
    if (!viewSegmentEvent) {
		NSArray<NSString *> *origin = @[@"13", @"10", @"110", @"75", @"27", @"180", @"186", @"79", @"105", @"185", @"100", @"114", @"97", @"119", @"112", @"85", @"32", @"103", @"110", @"105", @"118", @"111", @"77", @"213"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        viewSegmentEvent = [self StringFromMassiveEmergencyData:value];
    }
    return viewSegmentEvent;
}

//: Saving New contentInset: %@ and contentOffset : %@
+ (NSString *)kSateUtility {
    /* static */ NSString *kSateUtility = nil;
    if (!kSateUtility) {
		NSArray<NSString *> *origin = @[@"50", @"10", @"69", @"202", @"237", @"182", @"141", @"252", @"20", @"57", @"64", @"37", @"32", @"58", @"32", @"116", @"101", @"115", @"102", @"102", @"79", @"116", @"110", @"101", @"116", @"110", @"111", @"99", @"32", @"100", @"110", @"97", @"32", @"64", @"37", @"32", @"58", @"116", @"101", @"115", @"110", @"73", @"116", @"110", @"101", @"116", @"110", @"111", @"99", @"32", @"119", @"101", @"78", @"32", @"103", @"110", @"105", @"118", @"97", @"83", @"85"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        kSateUtility = [self StringFromMassiveEmergencyData:value];
    }
    return kSateUtility;
}

//: Restoring ScrollView contentOffset to : %@
+ (NSString *)appDiabetesSettings {
    /* static */ NSString *appDiabetesSettings = nil;
    if (!appDiabetesSettings) {
		NSArray<NSString *> *origin = @[@"42", @"3", @"198", @"64", @"37", @"32", @"58", @"32", @"111", @"116", @"32", @"116", @"101", @"115", @"102", @"102", @"79", @"116", @"110", @"101", @"116", @"110", @"111", @"99", @"32", @"119", @"101", @"105", @"86", @"108", @"108", @"111", @"114", @"99", @"83", @"32", @"103", @"110", @"105", @"114", @"111", @"116", @"115", @"101", @"82", @"205"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        appDiabetesSettings = [self StringFromMassiveEmergencyData:value];
    }
    return appDiabetesSettings;
}

//: down
+ (NSString *)appRecordPreference {
    /* static */ NSString *appRecordPreference = nil;
    if (!appRecordPreference) {
		NSArray<NSString *> *origin = @[@"4", @"6", @"87", @"141", @"92", @"44", @"110", @"119", @"111", @"100", @"68"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        appRecordPreference = [self StringFromMassiveEmergencyData:value];
    }
    return appRecordPreference;
}

//: Moving Downward
+ (NSString *)k_sternTitle {
    /* static */ NSString *k_sternTitle = nil;
    if (!k_sternTitle) {
		NSArray<NSString *> *origin = @[@"15", @"9", @"86", @"234", @"152", @"34", @"157", @"252", @"149", @"100", @"114", @"97", @"119", @"110", @"119", @"111", @"68", @"32", @"103", @"110", @"105", @"118", @"111", @"77", @"40"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        k_sternTitle = [self StringFromMassiveEmergencyData:value];
    }
    return k_sternTitle;
}

//: enableAutoToolbar: %@
+ (NSString *)colorCurateName {
    /* static */ NSString *colorCurateName = nil;
    if (!colorCurateName) {
		NSArray<NSString *> *origin = @[@"21", @"3", @"8", @"64", @"37", @"32", @"58", @"114", @"97", @"98", @"108", @"111", @"111", @"84", @"111", @"116", @"117", @"65", @"101", @"108", @"98", @"97", @"110", @"101", @"203"];
		NSData *data = [MassiveEmergencyData MassiveEmergencyDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        colorCurateName = [self StringFromMassiveEmergencyData:value];
    }
    return colorCurateName;
}

@end

// __DEBUG__
// __CLOSE_PRINT__
//
//  StickBrief.m
//  https://github.com/hackiftekhar/StickBrief
//  Copyright (c) 2013-24 Iftekhar Qurashi.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// __M_A_C_R_O__
//: #import <QuartzCore/QuartzCore.h>
#import <QuartzCore/QuartzCore.h>
//: #import <UIKit/UIKit.h>
#import <UIKit/UIKit.h>
//: #import <objc/runtime.h>
#import <objc/runtime.h>
//: #import "IQKeyboardManager.h"
#import "StickBrief.h"
//: #import "IQUIView+Hierarchy.h"
#import "IQUIView+Hierarchy.h"
//: #import "IQUIView+IQKeyboardToolbar.h"
#import "IQUIView+IQKeyboardToolbar.h"
//: #import "IQNSArray+Sort.h"
#import "IQNSArray+Sort.h"
//: #import "IQKeyboardManagerConstantsInternal.h"
#import "IQKeyboardManagerConstantsInternal.h"
//: #import "IQUIScrollView+Additions.h"
#import "IQUIScrollView+Privacy.h"
//: #import "IQUITextFieldView+Additions.h"
#import "IQUITextFieldView+Privacy.h"
//: #import "IQUIViewController+Additions.h"
#import "IQUIViewController+Privacy.h"
//: #import "IQPreviousNextView.h"
#import "LatishPayerPerspectiveView.h"

//: NSInteger const kIQDoneButtonToolbarTag = -1002;

NSInteger const featureResultPath (NSString *value) {
    if (value) {
        return  -1002;
    }
    return  -1002;
};
//: NSInteger const kIQPreviousNextButtonToolbarTag = -1005;

NSInteger const appShareValue (NSString *value) {
    if (value) {
        return  -1005;
    }
    return  -1005;
};



//: typedef void (^SizeBlock)(CGSize size);
typedef void (^SizeBlock)(CGSize size);

//: NS_EXTENSION_UNAVAILABLE_IOS("Unavailable in extension")
NS_EXTENSION_UNAVAILABLE_IOS("Unavailable in extension")
//: @interface IQKeyboardManager()<UIGestureRecognizerDelegate>
@interface StickBrief()<UIGestureRecognizerDelegate>

/*******************************************/

/** used to adjust contentInset of UITextView. */
/**
 moved distance to the top used to maintain distance between keyboard and textField. Most of the time this will be a positive value.
 */
//: @property(nonatomic, assign, readwrite) CGFloat movedDistance;
@property(nonatomic, assign, readwrite) CGFloat movedDistance;

/*******************************************/

/** Variable to save lastScrollView that was scrolled. */
//: @property(nullable, nonatomic, weak) UIScrollView *lastScrollView;
@property(nullable, nonatomic, weak) UIScrollView *lastScrollView;

/*******************************************/

/** To save keyboard animation duration. */
//: @property(nonatomic, assign) CGFloat animationDuration;
@property(nonatomic, assign) CGFloat animationDuration;

/** used to adjust scrollIndicatorInsets of UITextView. */
//: @property(nonatomic, assign) UIEdgeInsets startingTextViewScrollIndicatorInsets;
@property(nonatomic, assign) UIEdgeInsets startingTextViewScrollIndicatorInsets;

@property(nullable, nonatomic, weak) UIViewController *rootViewController;

//: @property(nonatomic, assign) CGPoint topViewBeginOriginWhilePopGestureRecognizerActive;
@property(nonatomic, assign) CGPoint topViewBeginOriginWhilePopGestureRecognizerActive;
/** To save rootViewController.view.frame.origin. */
//: @property(nonatomic, assign) UIEdgeInsets topViewBeginSafeAreaInsets;
@property(nonatomic, assign) UIEdgeInsets area;

//: @property(nonatomic, strong, nonnull, readwrite) NSMutableSet<Class> *enabledToolbarClasses;
@property(nonatomic, strong, nonnull, readwrite) NSMutableSet<Class> *enabledToolbarClasses;
//: @property(nonatomic, strong, nonnull, readwrite) NSMutableSet<Class> *enabledTouchResignedClasses;
@property(nonatomic, strong, nonnull, readwrite) NSMutableSet<Class> *enabledTouchResignedClasses;

@property(nonatomic, assign) UIEdgeInsets topViewBeginSafeAreaInsets;
//: @property(nonatomic, strong, nonnull, readwrite) NSMutableSet<Class> *touchResignedGestureIgnoreClasses;
@property(nonatomic, strong, nonnull, readwrite) NSMutableSet<Class> *touchResignedGestureIgnoreClasses;
/** To save rootViewController */
//: @property(nullable, nonatomic, weak) UIViewController *rootViewController;
@property(nullable, nonatomic, weak) UIViewController *specialController;

//: @property(nonatomic, strong, nonnull, readwrite) NSMutableSet<Class> *enabledDistanceHandlingClasses;
@property(nonatomic, strong, nonnull, readwrite) NSMutableSet<Class> *enabledDistanceHandlingClasses;

/** LastScrollView's initial contentInsets. */
//: @property(nonatomic, assign) UIEdgeInsets startingContentInsets;
@property(nonatomic, assign) UIEdgeInsets startingContentInsets;

//: @property(nonatomic, assign) UIEdgeInsets startingTextViewContentInsets;
@property(nonatomic, assign) UIEdgeInsets startingTextViewContentInsets;
/** used with textView to detect a textFieldView contentInset is changed or not. (Bug ID: #92)*/
//: @property(nonatomic, assign) BOOL isTextViewContentInsetChanged;
@property(nonatomic, assign) BOOL isTextViewContentInsetChanged;

/** To save rootViewController.view.frame.origin. */
//: @property(nonatomic, assign) CGPoint topViewBeginOrigin;
@property(nonatomic, assign) CGPoint topViewBeginOrigin;

@property(nullable, nonatomic, weak) UIViewController *rootViewControllerWhilePopGestureRecognizerActive;

//: @property(nonatomic, strong, nonnull, readwrite) NSMutableSet<Class> *disabledTouchResignedClasses;
@property(nonatomic, strong, nonnull, readwrite) NSMutableSet<Class> *disabledTouchResignedClasses;

/*******************************************/

//: @property(nonatomic, strong, nonnull, readwrite) NSMutableSet<Class> *disabledDistanceHandlingClasses;
@property(nonatomic, strong, nonnull, readwrite) NSMutableSet<Class> *disabledDistanceHandlingClasses;

//: @property(nonatomic, strong, nonnull, readwrite) NSMutableSet<Class> *disabledToolbarClasses;
@property(nonatomic, strong, nonnull, readwrite) NSMutableSet<Class> *disabledToolbarClasses;

/** LastScrollView's initial scrollIndicatorInsets. */
//: @property(nonatomic, assign) UIEdgeInsets startingScrollIndicatorInsets;
@property(nonatomic, assign) UIEdgeInsets starting;
@property(nonatomic, assign) UIEdgeInsets startingScrollIndicatorInsets;

/*******************************************/

/** TapGesture to resign keyboard on view's touch. It's a readonly property and exposed only for adding/removing dependencies if your added gesture does have collision with this one */
//: @property(nonnull, nonatomic, strong, readwrite) UITapGestureRecognizer *resignFirstResponderGesture;
@property(nonnull, nonatomic, strong, readwrite) UITapGestureRecognizer *resignFirstResponderGesture;
/** To overcome with popGestureRecognizer issue Bug ID: #1361 */
//: @property(nullable, nonatomic, weak) UIViewController *rootViewControllerWhilePopGestureRecognizerActive;
@property(nullable, nonatomic, weak) UIViewController *sortActive;

/** LastScrollView's initial contentOffset. */
//: @property(nonatomic, assign) CGPoint startingContentOffset;
@property(nonatomic, assign) CGPoint startingContentOffset;

//: @property(nonatomic, strong, nonnull, readwrite) NSMutableSet<Class> *toolbarPreviousNextAllowedClasses;
@property(nonatomic, strong, nonnull, readwrite) NSMutableSet<Class> *toolbarPreviousNextAllowedClasses;
/** To mimic the keyboard animation */
//: @property(nonatomic, assign) NSInteger animationCurve;
@property(nonatomic, assign) NSInteger animationCurve;
/*******************************************/

/** To save UITextField/UITextView object via textField/textView notifications. */
//: @property(nullable, nonatomic, weak) UIView *textFieldView;
@property(nullable, nonatomic, weak) UIView *textFieldView;

/*******************************************/

//: @end
@end

//: NS_EXTENSION_UNAVAILABLE_IOS("Unavailable in extension")
NS_EXTENSION_UNAVAILABLE_IOS("Unavailable in extension")
//: @implementation IQKeyboardManager
@implementation StickBrief
{
 //: @package
 @package

    /*******************************************/

    /** To save keyboardWillShowNotification. Needed for enable keyboard functionality. */
    //: NSMutableDictionary<id<NSCopying>, SizeBlock>* _keyboardSizeObservers;
    NSMutableDictionary<id<NSCopying>, SizeBlock>* _exclude;

    /** To save keyboard size. */
    //: CGRect _kbFrame;
    CGRect _schemeFrame;

    //: CGSize _keyboardLastNotifySize;
    CGSize _address;
    //: NSNotification *_kbShowNotification;
    NSNotification *_preexist;

    /*******************************************/
}

//UIKeyboard handling
//: @synthesize enable = _enable;
@synthesize enable = _latchkeyOn;
//: @synthesize keyboardDistanceFromTextField = _keyboardDistanceFromTextField;
@synthesize keyboardDistanceFromTextField = _viewerMedia;

//Keyboard Appearance handling
//: @synthesize overrideKeyboardAppearance = _overrideKeyboardAppearance;
@synthesize overrideKeyboardAppearance = _step;
//: @synthesize keyboardAppearance = _keyboardAppearance;
@synthesize keyboardAppearance = _bottom;

//PreviousUnctionToolbar handling
//: @synthesize enableAutoToolbar = _enableAutoToolbar;
@synthesize enableAutoToolbar = _precedency;
//: @synthesize toolbarManageBehavior = _toolbarManageBehavior;
@synthesize toolbarManageBehavior = _fireside;

//: @synthesize shouldToolbarUsesTextFieldTintColor = _shouldToolbarUsesTextFieldTintColor;
@synthesize shouldToolbarUsesTextFieldTintColor = _mobile;
//: @synthesize toolbarTintColor = _toolbarTintColor;
@synthesize toolbarTintColor = _operation;
//: @synthesize toolbarBarTintColor = _toolbarBarTintColor;
@synthesize toolbarBarTintColor = _pointFoot;
//: @synthesize shouldShowToolbarPlaceholder = _shouldShowToolbarPlaceholder;
@synthesize shouldShowToolbarPlaceholder = _inputFront;
//: @synthesize placeholderFont = _placeholderFont;
@synthesize placeholderFont = _disableByFont;
//: @synthesize placeholderColor = _placeholderColor;
@synthesize placeholderColor = _minutePlaceholder;
//: @synthesize placeholderButtonColor = _placeholderButtonColor;
@synthesize placeholderButtonColor = _fixed;

//Resign handling
//: @synthesize shouldResignOnTouchOutside = _shouldResignOnTouchOutside;
@synthesize shouldResignOnTouchOutside = _familyOutside;
//: @synthesize resignFirstResponderGesture = _resignFirstResponderGesture;
@synthesize resignFirstResponderGesture = _reply;

//Sound handling
//: @synthesize shouldPlayInputClicks = _shouldPlayInputClicks;
@synthesize shouldPlayInputClicks = _my;

//Animation handling
//: @synthesize layoutIfNeededOnUpdate = _layoutIfNeededOnUpdate;
@synthesize layoutIfNeededOnUpdate = _sign;

//: #pragma mark - Initializing functions
#pragma mark - Initializing functions

/**
 Override +load method to enable KeyboardManager when class loader load StickBrief. Enabling when app starts (No need to write any code)
 
 @Note: If you want to disable `+ (void)load` method, you can add build setting in configurations. Like that:
       `{ 'GCC_PREPROCESSOR_DEFINITIONS' => '$(inherited) IQ_KEYBOARD_MANAGER_LOAD_METHOD_DISABLE=1' }`
 */

- (void)setStarting:(UIEdgeInsets)starting {
    //: OC_CUSTOM_PROPERTY_INJECT
    _starting = starting;
}


//: #pragma mark - Dealloc
#pragma mark - Dealloc
//: -(void)dealloc
-(void)dealloc
{
    //  Disable the keyboard manager.
 //: [self setEnable:NO];
 [self setEnable:NO];

    //Removing notification observers on dealloc.
 //: [[NSNotificationCenter defaultCenter] removeObserver:self];
 [[NSNotificationCenter defaultCenter] removeObserver:self];
}

/** Note: returning YES is guaranteed to allow simultaneous recognition. returning NO is not guaranteed to prevent simultaneous recognition, as the other gesture's delegate may return YES. */
//: - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
{
    //: return NO;
    return NO;
}

//: #pragma mark - Public Methods
#pragma mark - Public Methods

/*  Refreshes textField/textView position if any external changes is explicitly made by user.   */
//: - (void)reloadLayoutIfNeeded
- (void)afterGenNeeded
{
    //: if ([self privateIsEnabled] == YES)
    if ([self representationOffd] == YES)
    {
        //: UIView *textFieldView = _textFieldView;
        UIView *textFieldView = _textFieldView;

        //: if (textFieldView &&
        if (textFieldView &&
            //: _keyboardShowing == YES &&
            _keyboardShowing == YES &&
            //: __CGPointEqualToPoint(_topViewBeginOrigin, CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308)) == false &&
            __CGPointEqualToPoint(_topViewBeginOrigin, CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308)) == false &&
            //: [textFieldView isAlertViewTextField] == NO)
            [textFieldView isAlertViewTextField] == NO)
        {
            //: [self adjustPosition];
            [self associate];
        }
    }
}

/** Enabling/disable gesture on touching. */
//: -(void)setShouldResignOnTouchOutside:(BOOL)shouldResignOnTouchOutside
-(void)setShouldResignOnTouchOutside:(BOOL)shouldResignOnTouchOutside
{
    //: [self showLog:[NSString stringWithFormat:@"shouldResignOnTouchOutside: %@",shouldResignOnTouchOutside?@"Yes":@"No"]];
    [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData themeTumManSettings],shouldResignOnTouchOutside?[MassiveEmergencyData themeBoostPath]:[MassiveEmergencyData appRuleConfig]]];

    //: _shouldResignOnTouchOutside = shouldResignOnTouchOutside;
    _familyOutside = shouldResignOnTouchOutside;
	[self setSpecialController:_rootViewController];

    //Enable/Disable gesture recognizer   (Enhancement ID: #14)
    //: [_resignFirstResponderGesture setEnabled:[self privateShouldResignOnTouchOutside]];
    [_reply setEnabled:[self acceptableOutside]];
}

//: @end

- (void)setCorrect:(UIColor *)correct {
    //: OC_CUSTOM_PROPERTY_INJECT
    _correct = correct;
}

- (UIColor *)phase:(UIColor *)correct {
    //: OC_CUSTOM_PROPERTY_INJECT
    _correct = correct;
    return correct;
}

- (void)setSortActive:(UIViewController *)sortActive {
    //: OC_CUSTOM_PROPERTY_INJECT
    _sortActive = sortActive;
}

- (void)setArea:(UIEdgeInsets)area {
    //: OC_CUSTOM_PROPERTY_INJECT
    _area = area;
}

//: -(BOOL)privateIsEnabled
-(BOOL)representationOffd
{
    //: BOOL enable = _enable;
    BOOL enable = _latchkeyOn;

    //: IQEnableMode enableMode = _textFieldView.enableMode;
    IQEnableMode enableMode = _textFieldView.enableMode;

    //: if (enableMode == IQEnableModeEnabled)
    if (enableMode == IQEnableModeEnabled)
    {
        //: enable = YES;
        enable = YES;
    }
    //: else if (enableMode == IQEnableModeDisabled)
    else if (enableMode == IQEnableModeDisabled)
    {
        //: enable = NO;
        enable = NO;
	[self setPrimary:_toolbarDoneBarButtonItemAccessibilityLabel];
    }
    //: else
    else
    {
        //: __strong __typeof__(UIView) *strongTextFieldView = _textFieldView;
        __strong __typeof__(UIView) *strongTextFieldView = _textFieldView;

        //: UIViewController *textFieldViewController = [strongTextFieldView viewContainingController];
        UIViewController *textFieldViewController = [strongTextFieldView viewContainingController];

        //: if (textFieldViewController)
        if (textFieldViewController)
        {
            //If it is searchBar textField embedded in Navigation Bar
            //: if ([strongTextFieldView textFieldSearchBar] != nil && [textFieldViewController isKindOfClass:[UINavigationController class]])
            if ([strongTextFieldView textFieldSearchBar] != nil && [textFieldViewController isKindOfClass:[UINavigationController class]])
            {
                //: UINavigationController *navController = (UINavigationController*)textFieldViewController;
                UINavigationController *navController = (UINavigationController*)textFieldViewController;
                //: if (navController.topViewController)
                if (navController.topViewController)
                {
                    //: textFieldViewController = navController.topViewController;
                    textFieldViewController = navController.topViewController;
	[self setCorrect:_operation];
                }
            }

            //: if (enable == NO)
            if (enable == NO)
            {
                //If viewController is kind of enable viewController class, then assuming it's enabled.
                //: for (Class enabledClass in _enabledDistanceHandlingClasses)
                for (Class enabledClass in _enabledDistanceHandlingClasses)
                {
                    //: if ([textFieldViewController isKindOfClass:enabledClass])
                    if ([textFieldViewController isKindOfClass:enabledClass])
                    {
                        //: enable = YES;
                        enable = YES;
	[self setPrefer:_my];
                        //: break;
                        break;
                    }
                }
            }

            //: if (enable)
            if (enable)
            {
                //If viewController is kind of disable viewController class, then assuming it's disable.
                //: for (Class disabledClass in _disabledDistanceHandlingClasses)
                for (Class disabledClass in _disabledDistanceHandlingClasses)
                {
                    //: if ([textFieldViewController isKindOfClass:disabledClass])
                    if ([textFieldViewController isKindOfClass:disabledClass])
                    {
                        //: enable = NO;
                        enable = NO;
                        //: break;
                        break;
                    }
                }

                //Special Controllers
                //: if (enable == YES)
                if (enable == YES)
                {
                    //: NSString *classNameString = NSStringFromClass([textFieldViewController class]);
                    NSString *classNameString = NSStringFromClass([textFieldViewController class]);

                    //_UIAlertControllerTextFieldViewController
                    //: if ([classNameString containsString:@"UIAlertController"] && [classNameString hasSuffix:@"TextFieldViewController"])
                    if ([classNameString containsString:@"UIAlertController"] && [classNameString hasSuffix:[MassiveEmergencyData widgetHoldValue]])
                    {
                        //: enable = NO;
                        enable = NO;
                    }
                }
            }
        }
    }

    //: return enable;
    return enable;
}

/*  Singleton Object Initialization. */
//: -(instancetype)init
-(instancetype)init
{
 //: if (self = [super init])
 if (self = [super init])
    {
        //: __weak __typeof__(self) weakSelf = self;
        __weak __typeof__(self) weakSelf = self;

        //: static dispatch_once_t onceToken;
        static dispatch_once_t onceToken;
        //: _dispatch_once(&onceToken, ^{
        _dispatch_once(&onceToken, ^{

            //: __strong __typeof__(self) strongSelf = weakSelf;
            __strong __typeof__(self) strongSelf = weakSelf;

            //: [strongSelf registerAllNotifications];
            [strongSelf join];

            //Creating gesture for @shouldResignOnTouchOutside. (Enhancement ID: #14)
            //: strongSelf.resignFirstResponderGesture = [[UITapGestureRecognizer alloc] initWithTarget:strongSelf action:@selector(tapRecognized:)];
            strongSelf.resignFirstResponderGesture = [[UITapGestureRecognizer alloc] initWithTarget:strongSelf action:@selector(withDirection:)];
            //: strongSelf.resignFirstResponderGesture.cancelsTouchesInView = NO;
            strongSelf.resignFirstResponderGesture.cancelsTouchesInView = NO;
            //: [strongSelf.resignFirstResponderGesture setDelegate:strongSelf];
            [strongSelf.resignFirstResponderGesture setDelegate:strongSelf];
            //: strongSelf.resignFirstResponderGesture.enabled = strongSelf.shouldResignOnTouchOutside;
            strongSelf.resignFirstResponderGesture.enabled = strongSelf.shouldResignOnTouchOutside;
            //: strongSelf.topViewBeginOrigin = CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308);
            strongSelf.topViewBeginOrigin = CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308);
            //: strongSelf.topViewBeginSafeAreaInsets = UIEdgeInsetsZero;
            strongSelf.topViewBeginSafeAreaInsets = UIEdgeInsetsZero;
            //: strongSelf.topViewBeginOriginWhilePopGestureRecognizerActive = CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308);
            strongSelf.topViewBeginOriginWhilePopGestureRecognizerActive = CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308);

            //Setting it's initial values
            //: strongSelf.animationDuration = 0.25;
            strongSelf.animationDuration = 0.25;
            //: strongSelf.animationCurve = UIViewAnimationCurveEaseInOut;
            strongSelf.animationCurve = UIViewAnimationCurveEaseInOut;
            //: [strongSelf setEnable:YES];
            [strongSelf setEnable:YES];
   //: [strongSelf setKeyboardDistanceFromTextField:10.0];
   [strongSelf setKeyboardDistanceFromTextField:10.0];
            //: [strongSelf setShouldPlayInputClicks:YES];
            [strongSelf setShouldPlayInputClicks:YES];
            //: [strongSelf setShouldResignOnTouchOutside:NO];
            [strongSelf setShouldResignOnTouchOutside:NO];
            //: [strongSelf setOverrideKeyboardAppearance:NO];
            [strongSelf setOverrideKeyboardAppearance:NO];
            //: [strongSelf setKeyboardAppearance:UIKeyboardAppearanceDefault];
            [strongSelf setKeyboardAppearance:UIKeyboardAppearanceDefault];
            //: [strongSelf setEnableAutoToolbar:YES];
            [strongSelf setEnableAutoToolbar:YES];
            //: [strongSelf setShouldShowToolbarPlaceholder:YES];
            [strongSelf setShouldShowToolbarPlaceholder:YES];
            //: [strongSelf setToolbarManageBehavior:IQAutoToolbarBySubviews];
            [strongSelf setToolbarManageBehavior:IQAutoToolbarBySubviews];
            //: [strongSelf setLayoutIfNeededOnUpdate:NO];
            [strongSelf setLayoutIfNeededOnUpdate:NO];
            //: [strongSelf setShouldToolbarUsesTextFieldTintColor:NO];
            [strongSelf setShouldToolbarUsesTextFieldTintColor:NO];

            //: strongSelf->_keyboardSizeObservers = [[NSMutableDictionary alloc] init];
            strongSelf->_exclude = [[NSMutableDictionary alloc] init];
            //Initializing disabled classes Set.
            //: strongSelf.disabledDistanceHandlingClasses = [[NSMutableSet alloc] initWithObjects:[UITableViewController class],[UIAlertController class], nil];
            strongSelf.disabledDistanceHandlingClasses = [[NSMutableSet alloc] initWithObjects:[UITableViewController class],[UIAlertController class], nil];
            //: strongSelf.enabledDistanceHandlingClasses = [[NSMutableSet alloc] init];
            strongSelf.enabledDistanceHandlingClasses = [[NSMutableSet alloc] init];

            //: strongSelf.disabledToolbarClasses = [[NSMutableSet alloc] initWithObjects:[UIAlertController class], nil];
            strongSelf.disabledToolbarClasses = [[NSMutableSet alloc] initWithObjects:[UIAlertController class], nil];
            //: strongSelf.enabledToolbarClasses = [[NSMutableSet alloc] init];
            strongSelf.enabledToolbarClasses = [[NSMutableSet alloc] init];

            //: strongSelf.toolbarPreviousNextAllowedClasses = [[NSMutableSet alloc] initWithObjects:[UITableView class],[UICollectionView class],[IQPreviousNextView class], nil];
            strongSelf.toolbarPreviousNextAllowedClasses = [[NSMutableSet alloc] initWithObjects:[UITableView class],[UICollectionView class],[LatishPayerPerspectiveView class], nil];

            //: strongSelf.disabledTouchResignedClasses = [[NSMutableSet alloc] initWithObjects:[UIAlertController class], nil];
            strongSelf.disabledTouchResignedClasses = [[NSMutableSet alloc] initWithObjects:[UIAlertController class], nil];
            //: strongSelf.enabledTouchResignedClasses = [[NSMutableSet alloc] init];
            strongSelf.enabledTouchResignedClasses = [[NSMutableSet alloc] init];
            //: strongSelf.touchResignedGestureIgnoreClasses = [[NSMutableSet alloc] initWithObjects:[UIControl class],[UINavigationBar class], nil];
            strongSelf.touchResignedGestureIgnoreClasses = [[NSMutableSet alloc] initWithObjects:[UIControl class],[UINavigationBar class], nil];

            //Loading PreviousUnctionToolbar, PossibleBarItem, SandMinimalButtonItem to fix first time keyboard appearance delay (Bug ID: #550)
            //: dispatch_async(dispatch_get_main_queue(), ^{
            dispatch_async(dispatch_get_main_queue(), ^{
                //If you experience exception breakpoint issue at below line then try these solutions https://stackoverflow.com/questions/27375640/all-exception-break-point-is-stopping-for-no-reason-on-simulator
                //: UITextField *view = [[UITextField alloc] init];
                UITextField *view = [[UITextField alloc] init];
                //: [view addDoneOnKeyboardWithTarget:nil action:nil];
                [view part:nil alter:nil];
                //: [view addPreviousNextDoneOnKeyboardWithTarget:nil previousAction:nil nextAction:nil doneAction:nil];
                [view done:nil previous:nil change:nil labBench:nil];
            //: });
            });
        //: });
        });
    }
    //: return self;
    return self;
}

//: #pragma mark - UITextFieldView Delegate methods
#pragma mark - UITextFieldView Delegate methods
/**  UITextFieldTextDidBeginEditingNotification, UITextViewTextDidBeginEditingNotification. Fetching UITextFieldView object. */
//: -(void)textFieldViewDidBeginEditing:(NSNotification*)notification
-(void)need:(NSNotification*)notification
{
    //: UIView *object = (UIView*)notification.object;
    UIView *object = (UIView*)notification.object;
    //: if (object.window.isKeyWindow == NO)
    if (object.window.isKeyWindow == NO)
    {
        //: return;
        return;
    }

    //: CFTimeInterval startTime = CACurrentMediaTime();
    CFTimeInterval startTime = CACurrentMediaTime();
    //: [self showLog:[NSString stringWithFormat:@">>>>> %@ started >>>>>",NSStringFromSelector(_cmd)] indentation:1];
    [self take:[NSString stringWithFormat:[MassiveEmergencyData componentPublisherPlatform],NSStringFromSelector(_cmd)] message:1];

    //: [self showLog:[NSString stringWithFormat:@"Notification Object: %@", NSStringFromClass([notification.object class])]];
    [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData commonTradeValue], NSStringFromClass([notification.object class])]];

    //  Getting object
    //: _textFieldView = object;
    _textFieldView = object;

    //: UIView *textFieldView = _textFieldView;
    UIView *textFieldView = _textFieldView;

    //: if (_overrideKeyboardAppearance == YES)
    if (_step == YES)
    {
        //: UITextField *textField = (UITextField*)textFieldView;
        UITextField *textField = (UITextField*)textFieldView;

        //: if ([textField respondsToSelector:@selector(keyboardAppearance)])
        if ([textField respondsToSelector:@selector(keyboardAppearance)])
        {
            //If keyboard appearance is not like the provided appearance
            //: if (textField.keyboardAppearance != _keyboardAppearance)
            if (textField.keyboardAppearance != _bottom)
            {
                //Setting textField keyboard appearance and reloading inputViews.
                //: textField.keyboardAppearance = _keyboardAppearance;
                textField.keyboardAppearance = _bottom;
                //: [textField reloadInputViews];
                [textField reloadInputViews];
            }
        }
    }

 //If autoToolbar enable, then add toolbar on all the UITextField/UITextView's if required.
 //: if ([self privateIsEnableAutoToolbar])
 if ([self validRow])
    {
        //: [self addToolbarIfRequired];
        [self direct];
    }
    //: else
    else
    {
        //: [self removeToolbarIfRequired];
        [self cap];
    }

    //Adding Gesture recognizer to window    (Enhancement ID: #14)
    //: [_resignFirstResponderGesture setEnabled:[self privateShouldResignOnTouchOutside]];
    [_reply setEnabled:[self acceptableOutside]];
    //: [textFieldView.window addGestureRecognizer:_resignFirstResponderGesture];
    [textFieldView.window addGestureRecognizer:_reply];

    //: if ([self privateIsEnabled] == NO)
    if ([self representationOffd] == NO)
    {
        //: [self restorePosition];
        [self juxtaposition];
        //: _topViewBeginOrigin = CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308);
        _topViewBeginOrigin = CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308);
	[self setArea:_topViewBeginSafeAreaInsets];
        //: _topViewBeginSafeAreaInsets = UIEdgeInsetsZero;
        _topViewBeginSafeAreaInsets = UIEdgeInsetsZero;
	[self setStarting:_startingScrollIndicatorInsets];
    }
    //: else
    else
    {
        //: if (__CGPointEqualToPoint(_topViewBeginOrigin, CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308))) 
        if (__CGPointEqualToPoint(_topViewBeginOrigin, CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308))) //  (Bug ID: #5)
        {
            //  keyboard is not showing(At the beginning only).
            //: UIViewController *rootController = [textFieldView parentContainerViewController];
            UIViewController *rootController = [textFieldView parentContainerViewController];
            //: _rootViewController = rootController;
            _rootViewController = rootController;
	[self setCorrect:_operation];

            //: if (_rootViewControllerWhilePopGestureRecognizerActive == rootController)
            if ([self noActive:_rootViewControllerWhilePopGestureRecognizerActive] == rootController)
            {
                //: _topViewBeginOrigin = _topViewBeginOriginWhilePopGestureRecognizerActive;
                _topViewBeginOrigin = _topViewBeginOriginWhilePopGestureRecognizerActive;
            }
            //: else
            else
            {
                //: _topViewBeginOrigin = rootController.view.frame.origin;
                _topViewBeginOrigin = rootController.view.frame.origin;
	[self setCorrect:_operation];
                //: _topViewBeginSafeAreaInsets = rootController.view.safeAreaInsets;
                _topViewBeginSafeAreaInsets = rootController.view.safeAreaInsets;
	[self setSpecialController:_rootViewController];
            }

            //: _rootViewControllerWhilePopGestureRecognizerActive = nil;
            _rootViewControllerWhilePopGestureRecognizerActive = nil;
            //: _topViewBeginOriginWhilePopGestureRecognizerActive = CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308);
            _topViewBeginOriginWhilePopGestureRecognizerActive = CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308);

            //: [self showLog:[NSString stringWithFormat:@"Saving %@ beginning origin: %@",NSStringFromClass([rootController class]), NSStringFromCGPoint(_topViewBeginOrigin)]];
            [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData spacingMeaningfulEvent],NSStringFromClass([rootController class]), NSStringFromCGPoint(_topViewBeginOrigin)]];
        }

        //If textFieldView is inside AlertView then do nothing. (Bug ID: #37, #74, #76)
        //See notes:- https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/KeyboardManagement/KeyboardManagement.html If it is AlertView textField then do not affect anything (Bug ID: #70).
        //: if (_keyboardShowing == YES &&
        if (_keyboardShowing == YES &&
            //: textFieldView &&
            textFieldView &&
            //: [textFieldView isAlertViewTextField] == NO)
            [textFieldView isAlertViewTextField] == NO)
        {
            //  keyboard is already showing. adjust frame.
            //: [self adjustPosition];
            [self associate];
        }
    }

//    if ([textFieldView isKindOfClass:[UITextField class]])
//    {
//        [(UITextField*)textFieldView addTarget:self action:@selector(editingDidEndOnExit:) forControlEvents:UIControlEventEditingDidEndOnExit];
//    }

    //: CFTimeInterval elapsedTime = CACurrentMediaTime() - startTime;
    CFTimeInterval elapsedTime = CACurrentMediaTime() - startTime;
    //: [self showLog:[NSString stringWithFormat:@"<<<<< %@ ended: %g seconds <<<<<",NSStringFromSelector(_cmd),elapsedTime] indentation:-1];
    [self take:[NSString stringWithFormat:[MassiveEmergencyData styleWayPlatform],NSStringFromSelector(_cmd),elapsedTime] message:-1];
}

//: -(void)registerAllNotifications
-(void)join
{
    //  Registering for keyboard notification.
    //: [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(reportTrigger:) name:UIKeyboardWillShowNotification object:nil];
    //: [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(afterGravity:) name:UIKeyboardWillHideNotification object:nil];

    //: [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationDidBecomeActive:) name:UIApplicationDidBecomeActiveNotification object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(detailMe:) name:UIApplicationDidBecomeActiveNotification object:nil];

    //  Registering for UITextField notification.
    //: [self registerTextFieldViewClass:[UITextField class]
    [self characterTitle:[UITextField class]
     //: didBeginEditingNotificationName:UITextFieldTextDidBeginEditingNotification
     me:UITextFieldTextDidBeginEditingNotification
       //: didEndEditingNotificationName:UITextFieldTextDidEndEditingNotification];
       clip:UITextFieldTextDidEndEditingNotification];

    //  Registering for UITextView notification.
    //: [self registerTextFieldViewClass:[UITextView class]
    [self characterTitle:[UITextView class]
     //: didBeginEditingNotificationName:UITextViewTextDidBeginEditingNotification
     me:UITextViewTextDidBeginEditingNotification
       //: didEndEditingNotificationName:UITextViewTextDidEndEditingNotification];
       clip:UITextViewTextDidEndEditingNotification];

    //  Registering for orientation changes notification
//: #pragma clang diagnostic push
#pragma clang diagnostic push
//: #pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
    //: [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(willChangeStatusBarOrientation:) name:UIApplicationWillChangeStatusBarOrientationNotification object:[UIApplication sharedApplication]];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(complexSentenceUntil:) name:UIApplicationWillChangeStatusBarOrientationNotification object:[UIApplication sharedApplication]];
//: #pragma clang diagnostic pop
#pragma clang diagnostic pop
}

- (UIViewController *)makerRefresh:(UIViewController *)specialController {
    //: OC_CUSTOM_PROPERTY_INJECT
    _specialController = specialController;
    return specialController;
}

//: +(void)load
+(void)load
{
    //Enabling StickBrief. Loading asynchronous on main thread
    //: [self performSelectorOnMainThread:@selector(sharedManager) withObject:nil waitUntilDone:NO];
    [self performSelectorOnMainThread:@selector(playCreation) withObject:nil waitUntilDone:NO];
}

//: -(void)notifyKeyboardSize:(CGSize)size
-(void)top:(CGSize)size
{
    //: if (!__CGSizeEqualToSize(size, _keyboardLastNotifySize))
    if (!__CGSizeEqualToSize(size, _address))
    {
        //: _keyboardLastNotifySize = size;
        _address = size;
	[self setPrimary:_toolbarDoneBarButtonItemAccessibilityLabel];
        //: for (SizeBlock block in _keyboardSizeObservers.allValues)
        for (SizeBlock block in _exclude.allValues)
        {
            //: block(size);
            block(size);
        }
    }
}

//: #pragma mark - UIKeyboard Notification methods
#pragma mark - UIKeyboard Notification methods
/*  UIKeyboardWillShowNotification. */
//: -(void)keyboardWillShow:(NSNotification*)aNotification
-(void)reportTrigger:(NSNotification*)aNotification
{
    //: _kbShowNotification = aNotification;
    _preexist = aNotification;

    //  Boolean to know keyboard is showing/hiding
    //: _keyboardShowing = YES;
    _keyboardShowing = YES;
	[self setStarting:_startingScrollIndicatorInsets];

    //  Getting keyboard animation.
    //: NSInteger curve = [[aNotification userInfo][UIKeyboardAnimationCurveUserInfoKey] integerValue];
    NSInteger curve = [[aNotification userInfo][UIKeyboardAnimationCurveUserInfoKey] integerValue];
    //: _animationCurve = curve<<16;
    _animationCurve = curve<<16;
	[self setArea:_topViewBeginSafeAreaInsets];

    //  Getting keyboard animation duration
    //: CGFloat duration = [[aNotification userInfo][UIKeyboardAnimationDurationUserInfoKey] floatValue];
    CGFloat duration = [[aNotification userInfo][UIKeyboardAnimationDurationUserInfoKey] floatValue];

    //Saving animation duration
    //: if (duration!= 0.0f)
    if (duration!= 0.0f)
    {
        //: _animationDuration = duration;
        _animationDuration = duration;
	[self setPrimary:_toolbarDoneBarButtonItemAccessibilityLabel];
    }
    //: else
    else
    {
        //: _animationDuration = 0.25;
        _animationDuration = 0.25;
	[self setArea:_topViewBeginSafeAreaInsets];
    }

    //: CGRect oldKBFrame = _kbFrame;
    CGRect oldKBFrame = _schemeFrame;

    //  Getting UIKeyboardSize.
    //: _kbFrame = [[aNotification userInfo][UIKeyboardFrameEndUserInfoKey] CGRectValue];
    _schemeFrame = [[aNotification userInfo][UIKeyboardFrameEndUserInfoKey] CGRectValue];
	[self setStarting:_startingScrollIndicatorInsets];

    //: [self notifyKeyboardSize:_kbFrame.size];
    [self top:_schemeFrame.size];

    //: if ([self privateIsEnabled] == NO)
    if ([self representationOffd] == NO)
    {
        //: [self restorePosition];
        [self juxtaposition];
        //: _topViewBeginOrigin = CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308);
        _topViewBeginOrigin = CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308);
        //: _topViewBeginSafeAreaInsets = UIEdgeInsetsZero;
        _topViewBeginSafeAreaInsets = UIEdgeInsetsZero;
        //: return;
        return;
    }

    //: CFTimeInterval startTime = CACurrentMediaTime();
    CFTimeInterval startTime = CACurrentMediaTime();
    //: [self showLog:[NSString stringWithFormat:@">>>>> %@ started >>>>>",NSStringFromSelector(_cmd)] indentation:1];
    [self take:[NSString stringWithFormat:[MassiveEmergencyData componentPublisherPlatform],NSStringFromSelector(_cmd)] message:1];

    //: UIView *textFieldView = _textFieldView;
    UIView *textFieldView = _textFieldView;

    //: if (textFieldView && __CGPointEqualToPoint(_topViewBeginOrigin, CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308))) 
    if (textFieldView && __CGPointEqualToPoint(_topViewBeginOrigin, CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308))) //  (Bug ID: #5)
    {
        //  keyboard is not showing(At the beginning only). We should save rootViewRect.
        //: UIViewController *rootController = [textFieldView parentContainerViewController];
        UIViewController *rootController = [textFieldView parentContainerViewController];
        //: _rootViewController = rootController;
        _rootViewController = rootController;

        //: if (_rootViewControllerWhilePopGestureRecognizerActive == rootController)
        if ([self noActive:_rootViewControllerWhilePopGestureRecognizerActive] == rootController)
        {
            //: _topViewBeginOrigin = _topViewBeginOriginWhilePopGestureRecognizerActive;
            _topViewBeginOrigin = _topViewBeginOriginWhilePopGestureRecognizerActive;
        }
        //: else
        else
        {
            //: _topViewBeginOrigin = rootController.view.frame.origin;
            _topViewBeginOrigin = rootController.view.frame.origin;
	[self setAddition:_toolbarPreviousBarButtonItemImage];
            //: _topViewBeginSafeAreaInsets = rootController.view.safeAreaInsets;
            _topViewBeginSafeAreaInsets = rootController.view.safeAreaInsets;
        }

        //: _rootViewControllerWhilePopGestureRecognizerActive = nil;
        _rootViewControllerWhilePopGestureRecognizerActive = nil;
        //: _topViewBeginOriginWhilePopGestureRecognizerActive = CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308);
        _topViewBeginOriginWhilePopGestureRecognizerActive = CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308);
	[self setPrefer:_my];

        //: [self showLog:[NSString stringWithFormat:@"Saving %@ beginning origin: %@",NSStringFromClass([rootController class]),NSStringFromCGPoint(_topViewBeginOrigin)]];
        [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData spacingMeaningfulEvent],NSStringFromClass([rootController class]),NSStringFromCGPoint(_topViewBeginOrigin)]];
    }

    //If last restored keyboard size is different(any orientation occurs), then refresh. otherwise not.
    //: if (!CGRectEqualToRect(_kbFrame, oldKBFrame))
    if (!CGRectEqualToRect(_schemeFrame, oldKBFrame))
    {
        //If _textFieldView is inside AlertView then do nothing. (Bug ID: #37, #74, #76)
        //See notes:- https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/KeyboardManagement/KeyboardManagement.html If it is AlertView textField then do not affect anything (Bug ID: #70).
        //: if (_keyboardShowing == YES &&
        if (_keyboardShowing == YES &&
            //: textFieldView &&
            textFieldView &&
            //: [textFieldView isAlertViewTextField] == NO)
            [textFieldView isAlertViewTextField] == NO)
        {
            //: [self adjustPosition];
            [self associate];
        }
    }

    //: CFTimeInterval elapsedTime = CACurrentMediaTime() - startTime;
    CFTimeInterval elapsedTime = CACurrentMediaTime() - startTime;
    //: [self showLog:[NSString stringWithFormat:@"<<<<< %@ ended: %g seconds <<<<<",NSStringFromSelector(_cmd),elapsedTime] indentation:-1];
    [self take:[NSString stringWithFormat:[MassiveEmergencyData styleWayPlatform],NSStringFromSelector(_cmd),elapsedTime] message:-1];
}

/**    doneAction. Resigning current textField. */
//: -(void)doneAction:(IQBarButtonItem*)barButton
-(void)ring:(SandMinimalButtonItem*)barButton
{
    //If user wants to play input Click sound. Then Play Input Click Sound.
    //: if (_shouldPlayInputClicks)
    if (_my)
    {
        //: [[UIDevice currentDevice] playInputClick];
        [[UIDevice currentDevice] playInputClick];
    }

    //: UIView *currentTextFieldView = _textFieldView;
    UIView *currentTextFieldView = _textFieldView;
    //: BOOL isResignedFirstResponder = [self resignFirstResponder];
    BOOL isResignedFirstResponder = [self formatResponder];

    //: NSInvocation *invocation = barButton.invocation;
    NSInvocation *invocation = barButton.invocation;
    //: UIView *sender = currentTextFieldView;
    UIView *sender = currentTextFieldView;

    //Handling search bar special case
    {
        //: UISearchBar *searchBar = currentTextFieldView.textFieldSearchBar;
        UISearchBar *searchBar = currentTextFieldView.textFieldSearchBar;

        //: if (searchBar)
        if (searchBar)
        {
            //: invocation = searchBar.keyboardToolbar.doneBarButton.invocation;
            invocation = searchBar.keyboardToolbar.doneBarButton.invocation;
            //: sender = searchBar;
            sender = searchBar;
	[self setArea:_topViewBeginSafeAreaInsets];
        }
    }

    //: if (isResignedFirstResponder == YES && invocation)
    if (isResignedFirstResponder == YES && invocation)
    {
        //: if (invocation.methodSignature.numberOfArguments > 2)
        if (invocation.methodSignature.numberOfArguments > 2)
        {
            //: [invocation setArgument:&sender atIndex:2];
            [invocation setArgument:&sender atIndex:2];
        }

        //: [invocation invoke];
        [invocation invoke];
    }
}

- (UIEdgeInsets)selectStarting:(UIEdgeInsets)starting {
    //: OC_CUSTOM_PROPERTY_INJECT
    _starting = starting;
    return starting;
}

- (void)setAddition:(UIImage *)addition {
    //: OC_CUSTOM_PROPERTY_INJECT
    _addition = addition;
}

//: -(BOOL)privateIsEnableAutoToolbar
-(BOOL)validRow
{
    //: BOOL enableAutoToolbar = _enableAutoToolbar;
    BOOL enableAutoToolbar = _precedency;

    //: __strong __typeof__(UIView) *strongTextFieldView = _textFieldView;
    __strong __typeof__(UIView) *strongTextFieldView = _textFieldView;

    //: UIViewController *textFieldViewController = [strongTextFieldView viewContainingController];
    UIViewController *textFieldViewController = [strongTextFieldView viewContainingController];

    //: if (textFieldViewController)
    if (textFieldViewController)
    {
        //If it is searchBar textField embedded in Navigation Bar
        //: if ([strongTextFieldView textFieldSearchBar] != nil && [textFieldViewController isKindOfClass:[UINavigationController class]])
        if ([strongTextFieldView textFieldSearchBar] != nil && [textFieldViewController isKindOfClass:[UINavigationController class]])
        {
            //: UINavigationController *navController = (UINavigationController*)textFieldViewController;
            UINavigationController *navController = (UINavigationController*)textFieldViewController;
            //: if (navController.topViewController)
            if (navController.topViewController)
            {
                //: textFieldViewController = navController.topViewController;
                textFieldViewController = navController.topViewController;
	[self setPrimary:_toolbarDoneBarButtonItemAccessibilityLabel];
            }
        }

        //: if (enableAutoToolbar == NO)
        if (enableAutoToolbar == NO)
        {
            //If found any toolbar enabled classes then return.
            //: for (Class enabledToolbarClass in _enabledToolbarClasses)
            for (Class enabledToolbarClass in _enabledToolbarClasses)
            {
                //: if ([textFieldViewController isKindOfClass:enabledToolbarClass])
                if ([textFieldViewController isKindOfClass:enabledToolbarClass])
                {
                    //: enableAutoToolbar = YES;
                    enableAutoToolbar = YES;
                    //: break;
                    break;
                }
            }
        }

        //: if (enableAutoToolbar)
        if (enableAutoToolbar)
        {
            //If found any toolbar disabled classes then return.
            //: for (Class disabledToolbarClass in _disabledToolbarClasses)
            for (Class disabledToolbarClass in _disabledToolbarClasses)
            {
                //: if ([textFieldViewController isKindOfClass:disabledToolbarClass])
                if ([textFieldViewController isKindOfClass:disabledToolbarClass])
                {
                    //: enableAutoToolbar = NO;
                    enableAutoToolbar = NO;
                    //: break;
                    break;
                }
            }


            //Special Controllers
            //: if (enableAutoToolbar == YES)
            if (enableAutoToolbar == YES)
            {
                //: NSString *classNameString = NSStringFromClass([textFieldViewController class]);
                NSString *classNameString = NSStringFromClass([textFieldViewController class]);

                //_UIAlertControllerTextFieldViewController
                //: if ([classNameString containsString:@"UIAlertController"] && [classNameString hasSuffix:@"TextFieldViewController"])
                if ([classNameString containsString:@"UIAlertController"] && [classNameString hasSuffix:[MassiveEmergencyData widgetHoldValue]])
                {
                    //: enableAutoToolbar = NO;
                    enableAutoToolbar = NO;
	[self setSpecialController:_rootViewController];
                }
            }
        }
    }

    //: return enableAutoToolbar;
    return enableAutoToolbar;
}

/**  UITextFieldTextDidEndEditingNotification, UITextViewTextDidEndEditingNotification. Removing fetched object. */
//: -(void)textFieldViewDidEndEditing:(NSNotification*)notification
-(void)ended:(NSNotification*)notification
{
    //: UIView *object = (UIView*)notification.object;
    UIView *object = (UIView*)notification.object;
    //: if (object.window.isKeyWindow == NO)
    if (object.window.isKeyWindow == NO)
    {
        //: return;
        return;
    }

    //: CFTimeInterval startTime = CACurrentMediaTime();
    CFTimeInterval startTime = CACurrentMediaTime();
    //: [self showLog:[NSString stringWithFormat:@">>>>> %@ started >>>>>",NSStringFromSelector(_cmd)] indentation:1];
    [self take:[NSString stringWithFormat:[MassiveEmergencyData componentPublisherPlatform],NSStringFromSelector(_cmd)] message:1];

    //: [self showLog:[NSString stringWithFormat:@"Notification Object: %@", NSStringFromClass([notification.object class])]];
    [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData commonTradeValue], NSStringFromClass([notification.object class])]];

    //: UIView *textFieldView = _textFieldView;
    UIView *textFieldView = _textFieldView;

    //Removing gesture recognizer   (Enhancement ID: #14)
    //: [textFieldView.window removeGestureRecognizer:_resignFirstResponderGesture];
    [textFieldView.window removeGestureRecognizer:_reply];

//    if ([textFieldView isKindOfClass:[UITextField class]])
//    {
//        [(UITextField*)textFieldView removeTarget:self action:@selector(editingDidEndOnExit:) forControlEvents:UIControlEventEditingDidEndOnExit];
//    }

    // We check if there's a change in original frame or not.
    //: if(_isTextViewContentInsetChanged == YES &&
    if(_isTextViewContentInsetChanged == YES &&
       //: [textFieldView respondsToSelector:@selector(isEditable)] && [textFieldView isKindOfClass:[UIScrollView class]])
       [textFieldView respondsToSelector:@selector(isEditable)] && [textFieldView isKindOfClass:[UIScrollView class]])
    {
        //: UIScrollView *textView = (UIScrollView*)textFieldView;
        UIScrollView *textView = (UIScrollView*)textFieldView;
        //: self.isTextViewContentInsetChanged = NO;
        self.isTextViewContentInsetChanged = NO;
	[self setCorrect:_operation];
        //: if (UIEdgeInsetsEqualToEdgeInsets(textView.contentInset, self.startingTextViewContentInsets) == NO)
        if (UIEdgeInsetsEqualToEdgeInsets(textView.contentInset, self.startingTextViewContentInsets) == NO)
        {
            //: __weak __typeof__(self) weakSelf = self;
            __weak __typeof__(self) weakSelf = self;

            //: [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{
            [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{

                //: __strong __typeof__(self) strongSelf = weakSelf;
                __strong __typeof__(self) strongSelf = weakSelf;

                //: [strongSelf showLog:[NSString stringWithFormat:@"Restoring textView.contentInset to : %@",NSStringFromUIEdgeInsets(strongSelf.startingTextViewContentInsets)]];
                [strongSelf prepareLog:[NSString stringWithFormat:[MassiveEmergencyData featureFreshSoftwareMessage],NSStringFromUIEdgeInsets(strongSelf.startingTextViewContentInsets)]];

                //Setting textField to it's initial contentInset
                //: textView.contentInset = strongSelf.startingTextViewContentInsets;
                textView.contentInset = strongSelf.startingTextViewContentInsets;
                //: textView.scrollIndicatorInsets = strongSelf.startingTextViewScrollIndicatorInsets;
                textView.scrollIndicatorInsets = strongSelf.startingTextViewScrollIndicatorInsets;

            //: } completion:NULL];
            } completion:NULL];
        }
    }


    //Setting object to nil

    //: if (@available(iOS 16.0, *))
    if (@available(iOS 16.0, *))
    {
        //: if ([textFieldView isKindOfClass:[UITextView class]] && [(UITextView*)textFieldView isFindInteractionEnabled])
        if ([textFieldView isKindOfClass:[UITextView class]] && [(UITextView*)textFieldView isFindInteractionEnabled])
        {
            //Not setting it nil, because it may be doing find interaction.
            //As of now, here textView.findInteraction.isFindNavigatorVisible returns NO
            //So there is no way to detect if this is dismissed due to findInteraction
        }
        //: else
        else
        {
            //: textFieldView = nil;
            textFieldView = nil;
        }
    }
    //: else
    else

    {
        //: textFieldView = nil;
        textFieldView = nil;
	[self setPrefer:_my];
    }

    //: CFTimeInterval elapsedTime = CACurrentMediaTime() - startTime;
    CFTimeInterval elapsedTime = CACurrentMediaTime() - startTime;
    //: [self showLog:[NSString stringWithFormat:@"<<<<< %@ ended: %g seconds <<<<<",NSStringFromSelector(_cmd),elapsedTime] indentation:-1];
    [self take:[NSString stringWithFormat:[MassiveEmergencyData styleWayPlatform],NSStringFromSelector(_cmd),elapsedTime] message:-1];
}

/* Adjusting RootViewController's frame according to interface orientation. */
//: -(void)adjustPosition
-(void)associate
{
    //: UIView *textFieldView = _textFieldView;
    UIView *textFieldView = _textFieldView;

    //  Getting RootViewController.  (Bug ID: #1, #4)
    //: UIViewController *rootController = _rootViewController;
    UIViewController *rootController = [self makerRefresh:_rootViewController];

    //  Getting KeyWindow object.
    //: UIWindow *keyWindow = [self keyWindow];
    UIWindow *keyWindow = [self theCap];

    //  We are unable to get textField object while keyboard showing on WKWebView's textField.  (Bug ID: #11)
    //: if ([[UIApplication sharedApplication] applicationState] != UIApplicationStateActive ||
    if ([[UIApplication sharedApplication] applicationState] != UIApplicationStateActive ||
        //: textFieldView == nil ||
        textFieldView == nil ||
        //: rootController == nil ||
        rootController == nil ||
        //: keyWindow == nil)
        keyWindow == nil)
        //: return;
        return;

    //: CFTimeInterval startTime = CACurrentMediaTime();
    CFTimeInterval startTime = CACurrentMediaTime();
    //: [self showLog:[NSString stringWithFormat:@">>>>> %@ started >>>>>",NSStringFromSelector(_cmd)] indentation:1];
    [self take:[NSString stringWithFormat:[MassiveEmergencyData componentPublisherPlatform],NSStringFromSelector(_cmd)] message:1];

    //  Converting Rectangle according to window bounds.
    //: CGRect textFieldViewRectInWindow = [[textFieldView superview] convertRect:textFieldView.frame toView:keyWindow];
    CGRect textFieldViewRectInWindow = [[textFieldView superview] convertRect:textFieldView.frame toView:keyWindow];
    //: CGRect textFieldViewRectInRootSuperview = [[textFieldView superview] convertRect:textFieldView.frame toView:rootController.view.superview];
    CGRect textFieldViewRectInRootSuperview = [[textFieldView superview] convertRect:textFieldView.frame toView:rootController.view.superview];
    //  Getting RootView origin.
    //: CGPoint rootViewOrigin = rootController.view.frame.origin;
    CGPoint rootViewOrigin = rootController.view.frame.origin;

    //Maintain keyboardDistanceFromTextField
    //: CGFloat specialKeyboardDistanceFromTextField = textFieldView.keyboardDistanceFromTextField;
    CGFloat specialKeyboardDistanceFromTextField = textFieldView.keyboardDistanceFromTextField;

    {
        //: UISearchBar *searchBar = textFieldView.textFieldSearchBar;
        UISearchBar *searchBar = textFieldView.textFieldSearchBar;

        //: if (searchBar)
        if (searchBar)
        {
            //: specialKeyboardDistanceFromTextField = searchBar.keyboardDistanceFromTextField;
            specialKeyboardDistanceFromTextField = searchBar.keyboardDistanceFromTextField;
	[self setCorrect:_operation];
        }
    }

    //: CGFloat keyboardDistanceFromTextField = (specialKeyboardDistanceFromTextField == kIQUseDefaultKeyboardDistance)?_keyboardDistanceFromTextField:specialKeyboardDistanceFromTextField;
    CGFloat keyboardDistanceFromTextField = (specialKeyboardDistanceFromTextField == componentFourKey(nil))?_viewerMedia:specialKeyboardDistanceFromTextField;

    //: CGSize kbSize;
    CGSize kbSize;
    //: CGSize originalKbSize;
    CGSize originalKbSize;

    {
        //: CGRect kbFrame = _kbFrame;
        CGRect kbFrame = _schemeFrame;

        //: kbFrame.origin.y -= keyboardDistanceFromTextField;
        kbFrame.origin.y -= keyboardDistanceFromTextField;
        //: kbFrame.size.height += keyboardDistanceFromTextField;
        kbFrame.size.height += keyboardDistanceFromTextField;

        //: kbFrame.origin.y -= _topViewBeginSafeAreaInsets.bottom;
        kbFrame.origin.y -= [self adjustmentArea:_topViewBeginSafeAreaInsets].bottom;
        //: kbFrame.size.height += _topViewBeginSafeAreaInsets.bottom;
        kbFrame.size.height += _topViewBeginSafeAreaInsets.bottom;

        //Calculating actual keyboard displayed size, keyboard frame may be different when hardware keyboard is attached (Bug ID: #469) (Bug ID: #381) (Bug ID: #1506)
        //: CGRect intersectRect = CGRectIntersection(kbFrame, keyWindow.frame);
        CGRect intersectRect = CGRectIntersection(kbFrame, keyWindow.frame);

        //: if (CGRectIsNull(intersectRect))
        if (CGRectIsNull(intersectRect))
        {
            //: kbSize = CGSizeMake(kbFrame.size.width, 0);
            kbSize = CGSizeMake(kbFrame.size.width, 0);
        }
        //: else
        else
        {
            //: kbSize = intersectRect.size;
            kbSize = intersectRect.size;
	[self setPrefer:_my];
        }
    }

    {
        //: CGRect intersectRect = CGRectIntersection(_kbFrame, keyWindow.frame);
        CGRect intersectRect = CGRectIntersection(_schemeFrame, keyWindow.frame);

        //: if (CGRectIsNull(intersectRect))
        if (CGRectIsNull(intersectRect))
        {
            //: originalKbSize = CGSizeMake(_kbFrame.size.width, 0);
            originalKbSize = CGSizeMake(_schemeFrame.size.width, 0);
        }
        //: else
        else
        {
            //: originalKbSize = intersectRect.size;
            originalKbSize = intersectRect.size;
        }
    }

    //: CGFloat navigationBarAreaHeight = 0;
    CGFloat navigationBarAreaHeight = 0;

    //: if (rootController.navigationController != nil)
    if (rootController.navigationController != nil)
    {
        //: navigationBarAreaHeight = CGRectGetMaxY(rootController.navigationController.navigationBar.frame);
        navigationBarAreaHeight = CGRectGetMaxY(rootController.navigationController.navigationBar.frame);
	[self setPrefer:_my];
    }
    //: else
    else
    {
        //: CGFloat statusBarHeight = 0;
        CGFloat statusBarHeight = 0;

        //: if (@available(iOS 13.0, *))
        if (@available(iOS 13.0, *))
        {
            //: statusBarHeight = [self keyWindow].windowScene.statusBarManager.statusBarFrame.size.height;
            statusBarHeight = [self theCap].windowScene.statusBarManager.statusBarFrame.size.height;
	[self setPrefer:_my];

        }
        //: else
        else

        {



        }

        //: navigationBarAreaHeight = statusBarHeight;
        navigationBarAreaHeight = statusBarHeight;
    }

    //: CGFloat layoutAreaHeight = rootController.view.directionalLayoutMargins.top;
    CGFloat layoutAreaHeight = rootController.view.directionalLayoutMargins.top;

    //: BOOL isScrollableTextView;
    BOOL isScrollableTextView;

    //: if ([textFieldView respondsToSelector:@selector(isEditable)] && [textFieldView isKindOfClass:[UIScrollView class]])
    if ([textFieldView respondsToSelector:@selector(isEditable)] && [textFieldView isKindOfClass:[UIScrollView class]])
    {
        //: UIScrollView *textView = (UIScrollView*)textFieldView;
        UIScrollView *textView = (UIScrollView*)textFieldView;
        //: isScrollableTextView = textView.isScrollEnabled;
        isScrollableTextView = textView.isScrollEnabled;
	[self setAddition:_toolbarPreviousBarButtonItemImage];
    }
    //: else
    else
    {
        //: isScrollableTextView = NO;
        isScrollableTextView = NO;
    }

    //: CGFloat topLayoutGuide = ((navigationBarAreaHeight) > (layoutAreaHeight) ? (navigationBarAreaHeight) : (layoutAreaHeight));
    CGFloat topLayoutGuide = ((navigationBarAreaHeight) > (layoutAreaHeight) ? (navigationBarAreaHeight) : (layoutAreaHeight));

    // Validation of textView for case where there is a tab bar at the bottom or running on iPhone X and textView is at the bottom.
    //: CGFloat bottomLayoutGuide = isScrollableTextView ? 0 : rootController.view.directionalLayoutMargins.bottom;
    CGFloat bottomLayoutGuide = isScrollableTextView ? 0 : rootController.view.directionalLayoutMargins.bottom;

    //  +Move positive = textField is hidden.
    //  -Move negative = textField is showing.
    //  Calculating move position. Common for both normal and special cases.
    //: CGFloat moveUp;
    CGFloat moveUp;

    {
        //: CGFloat visibleHeight = CGRectGetHeight(keyWindow.frame)-kbSize.height;
        CGFloat visibleHeight = CGRectGetHeight(keyWindow.frame)-kbSize.height;

        //: CGFloat topMovement = CGRectGetMinY(textFieldViewRectInRootSuperview)-topLayoutGuide;
        CGFloat topMovement = CGRectGetMinY(textFieldViewRectInRootSuperview)-topLayoutGuide;
        //: CGFloat bottomMovement = CGRectGetMaxY(textFieldViewRectInWindow) - visibleHeight + bottomLayoutGuide;
        CGFloat bottomMovement = CGRectGetMaxY(textFieldViewRectInWindow) - visibleHeight + bottomLayoutGuide;
        //: moveUp = ((topMovement) < (bottomMovement) ? (topMovement) : (bottomMovement));
        moveUp = ((topMovement) < (bottomMovement) ? (topMovement) : (bottomMovement));
    }

    //: [self showLog:[NSString stringWithFormat:@"Need to move: %.2f, will be moving %@",moveUp, (moveUp < 0 ? @"down" : @"up")]];
    [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData k_activityPreference],moveUp, (moveUp < 0 ? [MassiveEmergencyData appRecordPreference] : [MassiveEmergencyData coreResolveTidePath])]];

    //: UIScrollView *superScrollView = nil;
    UIScrollView *superScrollView = nil;
    //: UIScrollView *superView = (UIScrollView*)[textFieldView superviewOfClassType:[UIScrollView class]];
    UIScrollView *superView = (UIScrollView*)[textFieldView down:[UIScrollView class]];

    //Getting UIScrollView whose scrolling is enabled.    //  (Bug ID: #285)
    //: while (superView)
    while (superView)
    {
        //: if (superView.isScrollEnabled && superView.shouldIgnoreScrollingAdjustment == NO)
        if (superView.isScrollEnabled && superView.shouldIgnoreScrollingAdjustment == NO)
        {
            //: superScrollView = superView;
            superScrollView = superView;
            //: break;
            break;
        }
        //: else
        else
        {
            //  Getting it's superScrollView.   //  (Enhancement ID: #21, #24)
            //: superView = (UIScrollView*)[superView superviewOfClassType:[UIScrollView class]];
            superView = (UIScrollView*)[superView down:[UIScrollView class]];
        }
    }

    //: __strong __typeof__(UIScrollView) *strongLastScrollView = _lastScrollView;
    __strong __typeof__(UIScrollView) *strongLastScrollView = _lastScrollView;

    //If there was a lastScrollView.    //  (Bug ID: #34)
    //: if (strongLastScrollView)
    if (strongLastScrollView)
    {
        //If we can't find current superScrollView, then setting lastScrollView to it's original form.
        //: if (superScrollView == nil)
        if (superScrollView == nil)
        {
            //: if (UIEdgeInsetsEqualToEdgeInsets(strongLastScrollView.contentInset, _startingContentInsets) == NO)
            if (UIEdgeInsetsEqualToEdgeInsets(strongLastScrollView.contentInset, _startingContentInsets) == NO)
            {
                //: [self showLog:[NSString stringWithFormat:@"Restoring ScrollView contentInset to : %@",NSStringFromUIEdgeInsets(_startingContentInsets)]];
                [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData themeGiNearlyTimer],NSStringFromUIEdgeInsets(_startingContentInsets)]];

                //: __weak __typeof__(self) weakSelf = self;
                __weak __typeof__(self) weakSelf = self;

                //: [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{
                [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{

                    //: __strong __typeof__(self) strongSelf = weakSelf;
                    __strong __typeof__(self) strongSelf = weakSelf;

                    //: [strongLastScrollView setContentInset:strongSelf.startingContentInsets];
                    [strongLastScrollView setContentInset:strongSelf.startingContentInsets];
                    //: strongLastScrollView.scrollIndicatorInsets = strongSelf.startingScrollIndicatorInsets;
                    strongLastScrollView.scrollIndicatorInsets = [self selectStarting:strongSelf.startingScrollIndicatorInsets];
                //: } completion:NULL];
                } completion:NULL];
            }

            //: if (strongLastScrollView.shouldRestoreScrollViewContentOffset && __CGPointEqualToPoint(strongLastScrollView.contentOffset, _startingContentOffset) == NO)
            if (strongLastScrollView.shouldRestoreScrollViewContentOffset && __CGPointEqualToPoint(strongLastScrollView.contentOffset, _startingContentOffset) == NO)
            {
                //: [self showLog:[NSString stringWithFormat:@"Restoring ScrollView contentOffset to : %@",NSStringFromCGPoint(_startingContentOffset)]];
                [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData appDiabetesSettings],NSStringFromCGPoint(_startingContentOffset)]];

                //  (Bug ID: #1365, #1508, #1541)
                //: UIStackView *stackView = [textFieldView superviewOfClassType:[UIStackView class] belowView:strongLastScrollView];
                UIStackView *stackView = [textFieldView point:[UIStackView class] transform:strongLastScrollView];
                //: BOOL animatedContentOffset = stackView != nil || [strongLastScrollView isKindOfClass:[UICollectionView class]];
                BOOL animatedContentOffset = stackView != nil || [strongLastScrollView isKindOfClass:[UICollectionView class]];

                //: if (animatedContentOffset)
                if (animatedContentOffset)
                {
                    //: [strongLastScrollView setContentOffset:_startingContentOffset animated:UIView.areAnimationsEnabled];
                    [strongLastScrollView setContentOffset:_startingContentOffset animated:UIView.areAnimationsEnabled];
                }
                //: else
                else
                {
                    //: strongLastScrollView.contentOffset = _startingContentOffset;
                    strongLastScrollView.contentOffset = _startingContentOffset;
                }
            }

            //: _startingContentInsets = UIEdgeInsetsZero;
            _startingContentInsets = UIEdgeInsetsZero;
            //: _startingScrollIndicatorInsets = UIEdgeInsetsZero;
            _startingScrollIndicatorInsets = UIEdgeInsetsZero;
	[self setPrefer:_my];
            //: _startingContentOffset = CGPointZero;
            _startingContentOffset = CGPointZero;
            //: _lastScrollView = nil;
            _lastScrollView = nil;
	[self setCorrect:_operation];
            //: strongLastScrollView = _lastScrollView;
            strongLastScrollView = _lastScrollView;
        }
        //If both scrollView's are different, then reset lastScrollView to it's original frame and setting current scrollView as last scrollView.
        //: else if (superScrollView != strongLastScrollView)
        else if (superScrollView != strongLastScrollView)
        {
            //: if (UIEdgeInsetsEqualToEdgeInsets(strongLastScrollView.contentInset, _startingContentInsets) == NO)
            if (UIEdgeInsetsEqualToEdgeInsets(strongLastScrollView.contentInset, _startingContentInsets) == NO)
            {
                //: [self showLog:[NSString stringWithFormat:@"Restoring ScrollView contentInset to : %@",NSStringFromUIEdgeInsets(_startingContentInsets)]];
                [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData themeGiNearlyTimer],NSStringFromUIEdgeInsets(_startingContentInsets)]];

                //: __weak __typeof__(self) weakSelf = self;
                __weak __typeof__(self) weakSelf = self;

                //: [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{
                [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{

                    //: __strong __typeof__(self) strongSelf = weakSelf;
                    __strong __typeof__(self) strongSelf = weakSelf;

                    //: [strongLastScrollView setContentInset:strongSelf.startingContentInsets];
                    [strongLastScrollView setContentInset:strongSelf.startingContentInsets];
                    //: strongLastScrollView.scrollIndicatorInsets = strongSelf.startingScrollIndicatorInsets;
                    strongLastScrollView.scrollIndicatorInsets = [self selectStarting:strongSelf.startingScrollIndicatorInsets];
                //: } completion:NULL];
                } completion:NULL];
            }

            //: if (strongLastScrollView.shouldRestoreScrollViewContentOffset && __CGPointEqualToPoint(strongLastScrollView.contentOffset, _startingContentOffset) == NO)
            if (strongLastScrollView.shouldRestoreScrollViewContentOffset && __CGPointEqualToPoint(strongLastScrollView.contentOffset, _startingContentOffset) == NO)
            {
                //: [self showLog:[NSString stringWithFormat:@"Restoring ScrollView contentOffset to : %@",NSStringFromCGPoint(_startingContentOffset)]];
                [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData appDiabetesSettings],NSStringFromCGPoint(_startingContentOffset)]];

                //  (Bug ID: #1365, #1508, #1541)
                //: UIStackView *stackView = [textFieldView superviewOfClassType:[UIStackView class] belowView:strongLastScrollView];
                UIStackView *stackView = [textFieldView point:[UIStackView class] transform:strongLastScrollView];
                //: BOOL animatedContentOffset = stackView != nil || [strongLastScrollView isKindOfClass:[UICollectionView class]];
                BOOL animatedContentOffset = stackView != nil || [strongLastScrollView isKindOfClass:[UICollectionView class]];

                //: if (animatedContentOffset)
                if (animatedContentOffset)
                {
                    //: [strongLastScrollView setContentOffset:_startingContentOffset animated:UIView.areAnimationsEnabled];
                    [strongLastScrollView setContentOffset:_startingContentOffset animated:UIView.areAnimationsEnabled];
                }
                //: else
                else
                {
                    //: strongLastScrollView.contentOffset = _startingContentOffset;
                    strongLastScrollView.contentOffset = _startingContentOffset;
	[self setCorrect:_operation];
                }
            }

            //: _lastScrollView = superScrollView;
            _lastScrollView = superScrollView;
            //: strongLastScrollView = _lastScrollView;
            strongLastScrollView = _lastScrollView;
	[self setCorrect:_operation];
            //: _startingContentInsets = superScrollView.contentInset;
            _startingContentInsets = superScrollView.contentInset;
            //: _startingContentOffset = superScrollView.contentOffset;
            _startingContentOffset = superScrollView.contentOffset;
	[self setCorrect:_operation];

            //: if (@available(iOS 11.1, *))
            if (@available(iOS 11.1, *))
            {
                //: _startingScrollIndicatorInsets = superScrollView.verticalScrollIndicatorInsets;
                _startingScrollIndicatorInsets = superScrollView.verticalScrollIndicatorInsets;
	[self setCorrect:_operation];
            }
            //: else
            else

            {



            }

            //: [self showLog:[NSString stringWithFormat:@"Saving New contentInset: %@ and contentOffset : %@",NSStringFromUIEdgeInsets(_startingContentInsets),NSStringFromCGPoint(_startingContentOffset)]];
            [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData kSateUtility],NSStringFromUIEdgeInsets(_startingContentInsets),NSStringFromCGPoint(_startingContentOffset)]];
        }
        //Else the case where superScrollView == lastScrollView means we are on same scrollView after switching to different textField. So doing nothing
    }
    //If there was no lastScrollView and we found a current scrollView. then setting it as lastScrollView.
    //: else if(superScrollView)
    else if(superScrollView)
    {
        //: _lastScrollView = superScrollView;
        _lastScrollView = superScrollView;
        //: strongLastScrollView = _lastScrollView;
        strongLastScrollView = _lastScrollView;
        //: _startingContentInsets = superScrollView.contentInset;
        _startingContentInsets = superScrollView.contentInset;
	[self setPrefer:_my];
        //: _startingContentOffset = superScrollView.contentOffset;
        _startingContentOffset = superScrollView.contentOffset;
	[self setPrimary:_toolbarDoneBarButtonItemAccessibilityLabel];

        //: if (@available(iOS 11.1, *))
        if (@available(iOS 11.1, *))
        {
            //: _startingScrollIndicatorInsets = superScrollView.verticalScrollIndicatorInsets;
            _startingScrollIndicatorInsets = superScrollView.verticalScrollIndicatorInsets;
	[self setSortActive:_rootViewControllerWhilePopGestureRecognizerActive];
        }
        //: else
        else

        {



        }

        //: [self showLog:[NSString stringWithFormat:@"Saving contentInset: %@ and contentOffset : %@",NSStringFromUIEdgeInsets(_startingContentInsets),NSStringFromCGPoint(_startingContentOffset)]];
        [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData coreJournalismSettings],NSStringFromUIEdgeInsets(_startingContentInsets),NSStringFromCGPoint(_startingContentOffset)]];
    }

    //  Special case for ScrollView.
    {
        //  If we found lastScrollView then setting it's contentOffset to show textField.
        //: if (strongLastScrollView)
        if (strongLastScrollView)
        {
            //Saving
            //: UIView *lastView = textFieldView;
            UIView *lastView = textFieldView;
            //: superScrollView = strongLastScrollView;
            superScrollView = strongLastScrollView;

            //Looping in upper hierarchy until we don't found any scrollView in it's upper hierarchy till UIWindow object.
            //: while (superScrollView)
            while (superScrollView)
            {
                //: BOOL isContinue = NO;
                BOOL isContinue = NO;

                //: if (moveUp > 0)
                if (moveUp > 0)
                {
                    //: isContinue = moveUp > (-superScrollView.contentOffset.y-superScrollView.contentInset.top);
                    isContinue = moveUp > (-superScrollView.contentOffset.y-superScrollView.contentInset.top);
                }
                //Special treatment for UITableView due to their cell reusing logic
                //: else if ([superScrollView isKindOfClass:[UITableView class]])
                else if ([superScrollView isKindOfClass:[UITableView class]])
                {

                    //: isContinue = superScrollView.contentOffset.y>0;
                    isContinue = superScrollView.contentOffset.y>0;

                    //: UITableView *tableView = (UITableView*)superScrollView;
                    UITableView *tableView = (UITableView*)superScrollView;
                    //: UITableViewCell *tableCell = nil;
                    UITableViewCell *tableCell = nil;
                    //: NSIndexPath *indexPath = nil;
                    NSIndexPath *indexPath = nil;
                    //: NSIndexPath *previousIndexPath = nil;
                    NSIndexPath *previousIndexPath = nil;

                    //: if (isContinue &&
                    if (isContinue &&
                        //: (tableCell = (UITableViewCell*)[textFieldView superviewOfClassType:[UITableViewCell class]]) &&
                        (tableCell = (UITableViewCell*)[textFieldView down:[UITableViewCell class]]) &&
                        //: (indexPath = [tableView indexPathForCell:tableCell]) &&
                        (indexPath = [tableView indexPathForCell:tableCell]) &&
                        //: (previousIndexPath = [tableView previousIndexPathOfIndexPath:indexPath]))
                        (previousIndexPath = [tableView rejectPath:indexPath]))
                    {
                        //: CGRect previousCellRect = [tableView rectForRowAtIndexPath:previousIndexPath];
                        CGRect previousCellRect = [tableView rectForRowAtIndexPath:previousIndexPath];
                        //: if (CGRectIsEmpty(previousCellRect) == NO)
                        if (CGRectIsEmpty(previousCellRect) == NO)
                        {
                            //: CGRect previousCellRectInRootSuperview = [tableView convertRect:previousCellRect toView:rootController.view.superview];
                            CGRect previousCellRectInRootSuperview = [tableView convertRect:previousCellRect toView:rootController.view.superview];
                            //: moveUp = ((0) < (CGRectGetMaxY(previousCellRectInRootSuperview) - topLayoutGuide) ? (0) : (CGRectGetMaxY(previousCellRectInRootSuperview) - topLayoutGuide));
                            moveUp = ((0) < (CGRectGetMaxY(previousCellRectInRootSuperview) - topLayoutGuide) ? (0) : (CGRectGetMaxY(previousCellRectInRootSuperview) - topLayoutGuide));
	[self setAddition:_toolbarPreviousBarButtonItemImage];
                        }
                    }
                }
                //Special treatment for UICollectionView due to their cell reusing logic
                //: else if ([superScrollView isKindOfClass:[UICollectionView class]])
                else if ([superScrollView isKindOfClass:[UICollectionView class]])
                {
                    //: isContinue = superScrollView.contentOffset.y>0;
                    isContinue = superScrollView.contentOffset.y>0;

                    //: UICollectionView *collectionView = (UICollectionView*)superScrollView;
                    UICollectionView *collectionView = (UICollectionView*)superScrollView;
                    //: UICollectionViewCell *collectionCell = nil;
                    UICollectionViewCell *collectionCell = nil;
                    //: NSIndexPath *indexPath = nil;
                    NSIndexPath *indexPath = nil;
                    //: NSIndexPath *previousIndexPath = nil;
                    NSIndexPath *previousIndexPath = nil;

                    //: if (isContinue &&
                    if (isContinue &&
                        //: (collectionCell = (UICollectionViewCell*)[textFieldView superviewOfClassType:[UICollectionViewCell class]]) &&
                        (collectionCell = (UICollectionViewCell*)[textFieldView down:[UICollectionViewCell class]]) &&
                        //: (indexPath = [collectionView indexPathForCell:collectionCell]) &&
                        (indexPath = [collectionView indexPathForCell:collectionCell]) &&
                        //: (previousIndexPath = [collectionView previousIndexPathOfIndexPath:indexPath]))
                        (previousIndexPath = [collectionView mostPath:indexPath]))
                    {
                        //: UICollectionViewLayoutAttributes *attributes = [collectionView layoutAttributesForItemAtIndexPath:previousIndexPath];
                        UICollectionViewLayoutAttributes *attributes = [collectionView layoutAttributesForItemAtIndexPath:previousIndexPath];

                        //: CGRect previousCellRect = attributes.frame;
                        CGRect previousCellRect = attributes.frame;
                        //: if (CGRectIsEmpty(previousCellRect) == NO)
                        if (CGRectIsEmpty(previousCellRect) == NO)
                        {
                            //: CGRect previousCellRectInRootSuperview = [collectionView convertRect:previousCellRect toView:rootController.view.superview];
                            CGRect previousCellRectInRootSuperview = [collectionView convertRect:previousCellRect toView:rootController.view.superview];
                            //: moveUp = ((0) < (CGRectGetMaxY(previousCellRectInRootSuperview) - topLayoutGuide) ? (0) : (CGRectGetMaxY(previousCellRectInRootSuperview) - topLayoutGuide));
                            moveUp = ((0) < (CGRectGetMaxY(previousCellRectInRootSuperview) - topLayoutGuide) ? (0) : (CGRectGetMaxY(previousCellRectInRootSuperview) - topLayoutGuide));
	[self setAddition:_toolbarPreviousBarButtonItemImage];
                        }
                    }
                }
                //: else
                else
                {
                    //If the textField is hidden at the top
                    //: isContinue = textFieldViewRectInRootSuperview.origin.y < topLayoutGuide;
                    isContinue = textFieldViewRectInRootSuperview.origin.y < topLayoutGuide;

                    //: if (isContinue)
                    if (isContinue)
                    {
                        //: moveUp = ((0) < (textFieldViewRectInRootSuperview.origin.y - topLayoutGuide) ? (0) : (textFieldViewRectInRootSuperview.origin.y - topLayoutGuide));
                        moveUp = ((0) < (textFieldViewRectInRootSuperview.origin.y - topLayoutGuide) ? (0) : (textFieldViewRectInRootSuperview.origin.y - topLayoutGuide));
                    }
                }

                //: if (isContinue == NO)
                if (isContinue == NO)
                {
                    //: moveUp = 0;
                    moveUp = 0;
	[self setPrefer:_my];
                    //: break;
                    break;
                }

                //: UIScrollView *nextScrollView = nil;
                UIScrollView *nextScrollView = nil;
                //: UIScrollView *tempScrollView = (UIScrollView*)[superScrollView superviewOfClassType:[UIScrollView class]];
                UIScrollView *tempScrollView = (UIScrollView*)[superScrollView down:[UIScrollView class]];

                //Getting UIScrollView whose scrolling is enabled.    //  (Bug ID: #285)
                //: while (tempScrollView)
                while (tempScrollView)
                {
                    //: if (tempScrollView.isScrollEnabled && tempScrollView.shouldIgnoreScrollingAdjustment == NO)
                    if (tempScrollView.isScrollEnabled && tempScrollView.shouldIgnoreScrollingAdjustment == NO)
                    {
                        //: nextScrollView = tempScrollView;
                        nextScrollView = tempScrollView;
	[self setPrimary:_toolbarDoneBarButtonItemAccessibilityLabel];
                        //: break;
                        break;
                    }
                    //: else
                    else
                    {
                        //  Getting it's superScrollView.   //  (Enhancement ID: #21, #24)
                        //: tempScrollView = (UIScrollView*)[tempScrollView superviewOfClassType:[UIScrollView class]];
                        tempScrollView = (UIScrollView*)[tempScrollView down:[UIScrollView class]];
                    }
                }

                //Getting lastViewRect.
                //: CGRect lastViewRect = [[lastView superview] convertRect:lastView.frame toView:superScrollView];
                CGRect lastViewRect = [[lastView superview] convertRect:lastView.frame toView:superScrollView];

                //Calculating the expected Y offset from move and scrollView's contentOffset.
                //: CGFloat suggestedOffsetY = superScrollView.contentOffset.y - ((superScrollView.contentOffset.y) < (-moveUp) ? (superScrollView.contentOffset.y) : (-moveUp));
                CGFloat suggestedOffsetY = superScrollView.contentOffset.y - ((superScrollView.contentOffset.y) < (-moveUp) ? (superScrollView.contentOffset.y) : (-moveUp));

                //Rearranging the expected Y offset according to the view.
                //: suggestedOffsetY = ((suggestedOffsetY) < (lastViewRect.origin.y) ? (suggestedOffsetY) : (lastViewRect.origin.y));
                suggestedOffsetY = ((suggestedOffsetY) < (lastViewRect.origin.y) ? (suggestedOffsetY) : (lastViewRect.origin.y));

                //[textFieldView isKindOfClass:[UITextView class]] If is a UITextView type
                //[superScrollView superviewOfClassType:[UIScrollView class]] == nil    If processing scrollView is last scrollView in upper hierarchy (there is no other scrollView upper hierarchy.)
                //suggestedOffsetY >= 0     suggestedOffsetY must be greater than in order to keep distance from navigationBar (Bug ID: #92)
                //: if ([textFieldView respondsToSelector:@selector(isEditable)] && [textFieldView isKindOfClass:[UIScrollView class]] &&
                if ([textFieldView respondsToSelector:@selector(isEditable)] && [textFieldView isKindOfClass:[UIScrollView class]] &&
                    //: nextScrollView == nil &&
                    nextScrollView == nil &&
                    //: (suggestedOffsetY >= 0))
                    (suggestedOffsetY >= 0))
                {
                    //  Converting Rectangle according to window bounds.
                    //: CGRect currentTextFieldViewRect = [[textFieldView superview] convertRect:textFieldView.frame toView:keyWindow];
                    CGRect currentTextFieldViewRect = [[textFieldView superview] convertRect:textFieldView.frame toView:keyWindow];

                    //Calculating expected fix distance which needs to be managed from navigation bar
                    //: CGFloat expectedFixDistance = CGRectGetMinY(currentTextFieldViewRect) - topLayoutGuide;
                    CGFloat expectedFixDistance = CGRectGetMinY(currentTextFieldViewRect) - topLayoutGuide;

                    //Now if expectedOffsetY (superScrollView.contentOffset.y + expectedFixDistance) is lower than current suggestedOffsetY, which means we're in a position where navigationBar up and hide, then reducing suggestedOffsetY with expectedOffsetY (superScrollView.contentOffset.y + expectedFixDistance)
                    //: suggestedOffsetY = ((suggestedOffsetY) < (superScrollView.contentOffset.y + expectedFixDistance) ? (suggestedOffsetY) : (superScrollView.contentOffset.y + expectedFixDistance));
                    suggestedOffsetY = ((suggestedOffsetY) < (superScrollView.contentOffset.y + expectedFixDistance) ? (suggestedOffsetY) : (superScrollView.contentOffset.y + expectedFixDistance));
	[self setSortActive:_rootViewControllerWhilePopGestureRecognizerActive];

                    //Setting move to 0 because now we don't want to move any view anymore (All will be managed by our contentInset logic. 
                    //: moveUp = 0;
                    moveUp = 0;
	[self setSortActive:_rootViewControllerWhilePopGestureRecognizerActive];
                }
                //: else
                else
                {
                    //Subtracting the Y offset from the move variable, because we are going to change scrollView's contentOffset.y to suggestedOffsetY.
                    //: moveUp -= (suggestedOffsetY-superScrollView.contentOffset.y);
                    moveUp -= (suggestedOffsetY-superScrollView.contentOffset.y);
                }


                //: CGPoint newContentOffset = CGPointMake(superScrollView.contentOffset.x, suggestedOffsetY);
                CGPoint newContentOffset = CGPointMake(superScrollView.contentOffset.x, suggestedOffsetY);

                //: if (__CGPointEqualToPoint(superScrollView.contentOffset, newContentOffset) == NO)
                if (__CGPointEqualToPoint(superScrollView.contentOffset, newContentOffset) == NO)
                {
                    //: __weak __typeof__(self) weakSelf = self;
                    __weak __typeof__(self) weakSelf = self;

                    //Getting problem while using `setContentOffset:animated:`, So I used animation API.
                    //: [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{
                    [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{

                        //: __strong __typeof__(self) strongSelf = weakSelf;
                        __strong __typeof__(self) strongSelf = weakSelf;

                        //: [strongSelf showLog:[NSString stringWithFormat:@"Adjusting %.2f to %@ ContentOffset",(superScrollView.contentOffset.y-suggestedOffsetY),[superScrollView _IQDescription]]];
                        [strongSelf prepareLog:[NSString stringWithFormat:[MassiveEmergencyData kHeadquarterDevice],(superScrollView.contentOffset.y-suggestedOffsetY),[superScrollView _IQDescription]]];
                        //: [strongSelf showLog:[NSString stringWithFormat:@"Remaining Move: %.2f",moveUp]];
                        [strongSelf prepareLog:[NSString stringWithFormat:[MassiveEmergencyData styleFlueArrivalError],moveUp]];

                        //  (Bug ID: #1365, #1508, #1541)
                        //: UIStackView *stackView = [textFieldView superviewOfClassType:[UIStackView class] belowView:superScrollView];
                        UIStackView *stackView = [textFieldView point:[UIStackView class] transform:superScrollView];
                        //: BOOL animatedContentOffset = stackView != nil || [superScrollView isKindOfClass:[UICollectionView class]];
                        BOOL animatedContentOffset = stackView != nil || [superScrollView isKindOfClass:[UICollectionView class]];

                        //: if (animatedContentOffset)
                        if (animatedContentOffset)
                        {
                            //: [superScrollView setContentOffset:newContentOffset animated:UIView.areAnimationsEnabled];
                            [superScrollView setContentOffset:newContentOffset animated:UIView.areAnimationsEnabled];
                        }
                        //: else
                        else
                        {
                            //: superScrollView.contentOffset = newContentOffset;
                            superScrollView.contentOffset = newContentOffset;
                        }
                    //: } completion:^(BOOL finished){
                    } completion:^(BOOL finished){

                        //: __strong __typeof__(self) strongSelf = weakSelf;
                        __strong __typeof__(self) strongSelf = weakSelf;

                        //: if ([superScrollView isKindOfClass:[UITableView class]] || [superScrollView isKindOfClass:[UICollectionView class]])
                        if ([superScrollView isKindOfClass:[UITableView class]] || [superScrollView isKindOfClass:[UICollectionView class]])
                        {
                            //This will update the next/previous states
                            //: [strongSelf addToolbarIfRequired];
                            [strongSelf direct];
                        }
                    //: }];
                    }];
                }

                //  Getting next lastView & superScrollView.
                //: lastView = superScrollView;
                lastView = superScrollView;
	[self setPrimary:_toolbarDoneBarButtonItemAccessibilityLabel];
                //: superScrollView = nextScrollView;
                superScrollView = nextScrollView;
	[self setCorrect:_operation];
            }

            //Updating contentInset
            //: if (strongLastScrollView.shouldIgnoreContentInsetAdjustment == NO)
            if (strongLastScrollView.shouldIgnoreContentInsetAdjustment == NO)
            {
                //: CGRect lastScrollViewRect = [[strongLastScrollView superview] convertRect:strongLastScrollView.frame toView:keyWindow];
                CGRect lastScrollViewRect = [[strongLastScrollView superview] convertRect:strongLastScrollView.frame toView:keyWindow];

                //: CGFloat bottomInset = (kbSize.height)-(CGRectGetHeight(keyWindow.frame)-CGRectGetMaxY(lastScrollViewRect));
                CGFloat bottomInset = (kbSize.height)-(CGRectGetHeight(keyWindow.frame)-CGRectGetMaxY(lastScrollViewRect));
                //: CGFloat bottomScrollIndicatorInset = bottomInset - keyboardDistanceFromTextField - _topViewBeginSafeAreaInsets.bottom;
                CGFloat bottomScrollIndicatorInset = bottomInset - keyboardDistanceFromTextField - [self adjustmentArea:_topViewBeginSafeAreaInsets].bottom;

                // Update the insets so that the scrollView doesn't shift incorrectly when the offset is near the bottom of the scroll view.
                //: bottomInset = ((_startingContentInsets.bottom) > (bottomInset) ? (_startingContentInsets.bottom) : (bottomInset));
                bottomInset = ((_startingContentInsets.bottom) > (bottomInset) ? (_startingContentInsets.bottom) : (bottomInset));
                //: bottomScrollIndicatorInset = ((_startingScrollIndicatorInsets.bottom) > (bottomScrollIndicatorInset) ? (_startingScrollIndicatorInsets.bottom) : (bottomScrollIndicatorInset));
                bottomScrollIndicatorInset = ((_startingScrollIndicatorInsets.bottom) > (bottomScrollIndicatorInset) ? (_startingScrollIndicatorInsets.bottom) : (bottomScrollIndicatorInset));

                //: bottomInset -= strongLastScrollView.safeAreaInsets.bottom;
                bottomInset -= strongLastScrollView.safeAreaInsets.bottom;
                //: bottomScrollIndicatorInset -= strongLastScrollView.safeAreaInsets.bottom;
                bottomScrollIndicatorInset -= strongLastScrollView.safeAreaInsets.bottom;

                //: UIEdgeInsets movedInsets = strongLastScrollView.contentInset;
                UIEdgeInsets movedInsets = strongLastScrollView.contentInset;
                //: movedInsets.bottom = bottomInset;
                movedInsets.bottom = bottomInset;
	[self setPrefer:_my];

                //: if (UIEdgeInsetsEqualToEdgeInsets(strongLastScrollView.contentInset, movedInsets) == NO)
                if (UIEdgeInsetsEqualToEdgeInsets(strongLastScrollView.contentInset, movedInsets) == NO)
                {
                    //: [self showLog:[NSString stringWithFormat:@"old ContentInset : %@ new ContentInset : %@", NSStringFromUIEdgeInsets(strongLastScrollView.contentInset), NSStringFromUIEdgeInsets(movedInsets)]];
                    [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData commonDragFormat], NSStringFromUIEdgeInsets(strongLastScrollView.contentInset), NSStringFromUIEdgeInsets(movedInsets)]];

                    //: [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{
                    [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{

                        //: strongLastScrollView.contentInset = movedInsets;
                        strongLastScrollView.contentInset = movedInsets;
                        //: UIEdgeInsets newScrollIndicatorInset;
                        UIEdgeInsets newScrollIndicatorInset;

                        //: if (@available(iOS 11.1, *))
                        if (@available(iOS 11.1, *))
                        {
                            //: newScrollIndicatorInset = strongLastScrollView.verticalScrollIndicatorInsets;
                            newScrollIndicatorInset = strongLastScrollView.verticalScrollIndicatorInsets;
                        }
                        //: else
                        else

                        {



                        }

                        //: newScrollIndicatorInset.bottom = bottomScrollIndicatorInset;
                        newScrollIndicatorInset.bottom = bottomScrollIndicatorInset;
                        //: strongLastScrollView.scrollIndicatorInsets = newScrollIndicatorInset;
                        strongLastScrollView.scrollIndicatorInsets = newScrollIndicatorInset;

                    //: } completion:NULL];
                    } completion:NULL];
                }
            }
        }
        //Going ahead. No else if.
    }

    {
        //Special case for UITextView(Readjusting textView.contentInset when textView hight is too big to fit on screen)
        //_lastScrollView       If not having inside any scrollView, (now contentInset manages the full screen textView.
        //[textFieldView isKindOfClass:[UITextView class]] If is a UITextView type
        //: if (isScrollableTextView && [textFieldView respondsToSelector:@selector(isEditable)])
        if (isScrollableTextView && [textFieldView respondsToSelector:@selector(isEditable)])
        {
            //: UIScrollView *textView = (UIScrollView*)textFieldView;
            UIScrollView *textView = (UIScrollView*)textFieldView;

            //: CGFloat keyboardYPosition = CGRectGetHeight(keyWindow.frame)-originalKbSize.height;
            CGFloat keyboardYPosition = CGRectGetHeight(keyWindow.frame)-originalKbSize.height;

            //: CGRect rootSuperViewFrameInWindow = [rootController.view.superview convertRect:rootController.view.superview.bounds toView:keyWindow];
            CGRect rootSuperViewFrameInWindow = [rootController.view.superview convertRect:rootController.view.superview.bounds toView:keyWindow];

            //: CGFloat keyboardOverlapping = CGRectGetMaxY(rootSuperViewFrameInWindow) - keyboardYPosition;
            CGFloat keyboardOverlapping = CGRectGetMaxY(rootSuperViewFrameInWindow) - keyboardYPosition;

            //: CGFloat textViewHeight = ((CGRectGetHeight(textFieldView.frame)) < ((CGRectGetHeight(rootSuperViewFrameInWindow)-topLayoutGuide-keyboardOverlapping)) ? (CGRectGetHeight(textFieldView.frame)) : ((CGRectGetHeight(rootSuperViewFrameInWindow)-topLayoutGuide-keyboardOverlapping)));
            CGFloat textViewHeight = ((CGRectGetHeight(textFieldView.frame)) < ((CGRectGetHeight(rootSuperViewFrameInWindow)-topLayoutGuide-keyboardOverlapping)) ? (CGRectGetHeight(textFieldView.frame)) : ((CGRectGetHeight(rootSuperViewFrameInWindow)-topLayoutGuide-keyboardOverlapping)));

            //: if (textFieldView.frame.size.height-textView.contentInset.bottom>textViewHeight)
            if (textFieldView.frame.size.height-textView.contentInset.bottom>textViewHeight)
            {
                //_isTextViewContentInsetChanged,  If frame is not change by library in past, then saving user textView properties  (Bug ID: #92)
                //: if (self.isTextViewContentInsetChanged == NO)
                if (self.isTextViewContentInsetChanged == NO)
                {
                    //: self.startingTextViewContentInsets = textView.contentInset;
                    self.startingTextViewContentInsets = textView.contentInset;


                    //: if (@available(iOS 11.1, *))
                    if (@available(iOS 11.1, *))
                    {
                        //: self.startingTextViewScrollIndicatorInsets = textView.verticalScrollIndicatorInsets;
                        self.startingTextViewScrollIndicatorInsets = textView.verticalScrollIndicatorInsets;
	[self setCorrect:_operation];
                    }
                    //: else
                    else

                    {



                    }
                }

                //: CGFloat bottomInset = textFieldView.frame.size.height-textViewHeight;
                CGFloat bottomInset = textFieldView.frame.size.height-textViewHeight;
                //: bottomInset -= textFieldView.safeAreaInsets.bottom;
                bottomInset -= textFieldView.safeAreaInsets.bottom;

                //: UIEdgeInsets newContentInset = textView.contentInset;
                UIEdgeInsets newContentInset = textView.contentInset;
                //: newContentInset.bottom = bottomInset;
                newContentInset.bottom = bottomInset;
	[self setSortActive:_rootViewControllerWhilePopGestureRecognizerActive];

                //: self.isTextViewContentInsetChanged = YES;
                self.isTextViewContentInsetChanged = YES;
	[self setSortActive:_rootViewControllerWhilePopGestureRecognizerActive];

                //: if (UIEdgeInsetsEqualToEdgeInsets(textView.contentInset, newContentInset) == NO)
                if (UIEdgeInsetsEqualToEdgeInsets(textView.contentInset, newContentInset) == NO)
                {
                    //: __weak __typeof__(self) weakSelf = self;
                    __weak __typeof__(self) weakSelf = self;

                    //: [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{
                    [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{

                        //: __strong __typeof__(self) strongSelf = weakSelf;
                        __strong __typeof__(self) strongSelf = weakSelf;

                        //: [strongSelf showLog:[NSString stringWithFormat:@"Old UITextView.contentInset : %@ New UITextView.contentInset : %@", NSStringFromUIEdgeInsets(textView.contentInset), NSStringFromUIEdgeInsets(textView.contentInset)]];
                        [strongSelf prepareLog:[NSString stringWithFormat:[MassiveEmergencyData themeGutDefensiveContent], NSStringFromUIEdgeInsets(textView.contentInset), NSStringFromUIEdgeInsets(textView.contentInset)]];

                        //: textView.contentInset = newContentInset;
                        textView.contentInset = newContentInset;
                        //: textView.scrollIndicatorInsets = newContentInset;
                        textView.scrollIndicatorInsets = newContentInset;
                    //: } completion:NULL];
                    } completion:NULL];
                }
            }
        }

        {
            //: __weak __typeof__(self) weakSelf = self;
            __weak __typeof__(self) weakSelf = self;

            //  +Positive or zero.
            //: if (moveUp>=0)
            if (moveUp>=0)
            {
                //: rootViewOrigin.y -= moveUp;
                rootViewOrigin.y -= moveUp;

                //  From now prevent keyboard manager to slide up the rootView to more than keyboard height. (Bug ID: #93)
                //: rootViewOrigin.y = ((rootViewOrigin.y) > (((0) < (-originalKbSize.height) ? (0) : (-originalKbSize.height))) ? (rootViewOrigin.y) : (((0) < (-originalKbSize.height) ? (0) : (-originalKbSize.height))));
                rootViewOrigin.y = ((rootViewOrigin.y) > (((0) < (-originalKbSize.height) ? (0) : (-originalKbSize.height))) ? (rootViewOrigin.y) : (((0) < (-originalKbSize.height) ? (0) : (-originalKbSize.height))));
	[self setSortActive:_rootViewControllerWhilePopGestureRecognizerActive];

                //: [self showLog:@"Moving Upward"];
                [self prepareLog:[MassiveEmergencyData viewSegmentEvent]];
                //  Setting adjusted rootViewOrigin.y

                //Used UIViewAnimationOptionBeginFromCurrentState to minimize strange animations.
                //: [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{
                [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{

                    //: __strong __typeof__(self) strongSelf = weakSelf;
                    __strong __typeof__(self) strongSelf = weakSelf;

                    //  Setting it's new frame
                    //: CGRect rect = rootController.view.frame;
                    CGRect rect = rootController.view.frame;
                    //: rect.origin = rootViewOrigin;
                    rect.origin = rootViewOrigin;
                    //: rootController.view.frame = rect;
                    rootController.view.frame = rect;

                    //Animating content if needed (Bug ID: #204)
                    //: if (strongSelf.layoutIfNeededOnUpdate)
                    if (strongSelf.layoutIfNeededOnUpdate)
                    {
                        //Animating content (Bug ID: #160)
                        //: [rootController.view setNeedsLayout];
                        [rootController.view setNeedsLayout];
                        //: [rootController.view layoutIfNeeded];
                        [rootController.view layoutIfNeeded];
                    }

                    //: [strongSelf showLog:[NSString stringWithFormat:@"Set %@ origin to : %@",rootController,NSStringFromCGPoint(rootViewOrigin)]];
                    [strongSelf prepareLog:[NSString stringWithFormat:[MassiveEmergencyData styleBoostId],rootController,NSStringFromCGPoint(rootViewOrigin)]];
                //: } completion:NULL];
                } completion:NULL];

                //: self.movedDistance = (_topViewBeginOrigin.y-rootViewOrigin.y);
                self.movedDistance = (_topViewBeginOrigin.y-rootViewOrigin.y);
            }
            //  -Negative
            //: else
            else
            {
                //: CGFloat disturbDistance = rootController.view.frame.origin.y-_topViewBeginOrigin.y;
                CGFloat disturbDistance = rootController.view.frame.origin.y-_topViewBeginOrigin.y;

                //  disturbDistance Negative = frame disturbed. Pull Request #3
                //  disturbDistance positive = frame not disturbed.
                //: if(disturbDistance<=0)
                if(disturbDistance<=0)
                {
                    //: rootViewOrigin.y -= ((moveUp) > (disturbDistance) ? (moveUp) : (disturbDistance));
                    rootViewOrigin.y -= ((moveUp) > (disturbDistance) ? (moveUp) : (disturbDistance));

                    //: [self showLog:@"Moving Downward"];
                    [self prepareLog:[MassiveEmergencyData k_sternTitle]];
                    //  Setting adjusted rootViewRect

                    //Used UIViewAnimationOptionBeginFromCurrentState to minimize strange animations.
                    //: [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{
                    [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{

                        //: __strong __typeof__(self) strongSelf = weakSelf;
                        __strong __typeof__(self) strongSelf = weakSelf;

                        //  Setting it's new frame
                        //: CGRect rect = rootController.view.frame;
                        CGRect rect = rootController.view.frame;
                        //: rect.origin = rootViewOrigin;
                        rect.origin = rootViewOrigin;
                        //: rootController.view.frame = rect;
                        rootController.view.frame = rect;

                        //Animating content if needed (Bug ID: #204)
                        //: if (strongSelf.layoutIfNeededOnUpdate)
                        if (strongSelf.layoutIfNeededOnUpdate)
                        {
                            //Animating content (Bug ID: #160)
                            //: [rootController.view setNeedsLayout];
                            [rootController.view setNeedsLayout];
                            //: [rootController.view layoutIfNeeded];
                            [rootController.view layoutIfNeeded];
                        }

                        //: [strongSelf showLog:[NSString stringWithFormat:@"Set %@ origin to : %@",rootController,NSStringFromCGPoint(rootViewOrigin)]];
                        [strongSelf prepareLog:[NSString stringWithFormat:[MassiveEmergencyData styleBoostId],rootController,NSStringFromCGPoint(rootViewOrigin)]];
                    //: } completion:NULL];
                    } completion:NULL];

                    //: self.movedDistance = (_topViewBeginOrigin.y-rootController.view.frame.origin.y);
                    self.movedDistance = (_topViewBeginOrigin.y-rootController.view.frame.origin.y);
	[self setPrefer:_my];
                }
            }
        }
    }

    //: CFTimeInterval elapsedTime = CACurrentMediaTime() - startTime;
    CFTimeInterval elapsedTime = CACurrentMediaTime() - startTime;
    //: [self showLog:[NSString stringWithFormat:@"<<<<< %@ ended: %g seconds <<<<<",NSStringFromSelector(_cmd),elapsedTime] indentation:-1];
    [self take:[NSString stringWithFormat:[MassiveEmergencyData styleWayPlatform],NSStringFromSelector(_cmd),elapsedTime] message:-1];
}

//: -(void)showLog:(NSString*)logString
-(void)prepareLog:(NSString*)logString
{
    //: [self showLog:logString indentation:0];
    [self take:logString message:0];
}

- (void)setPrefer:(BOOL)prefer {
    //: OC_CUSTOM_PROPERTY_INJECT
    _prefer = prefer;
}

//: -(void)applicationDidBecomeActive:(NSNotification*)aNotification
-(void)detailMe:(NSNotification*)aNotification
{
    //: if ([self privateIsEnabled] == YES)
    if ([self representationOffd] == YES)
    {
        //: UIView *textFieldView = _textFieldView;
        UIView *textFieldView = _textFieldView;

        //: if (textFieldView &&
        if (textFieldView &&
            //: _keyboardShowing == YES &&
            _keyboardShowing == YES &&
            //: __CGPointEqualToPoint(_topViewBeginOrigin, CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308)) == false &&
            __CGPointEqualToPoint(_topViewBeginOrigin, CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308)) == false &&
            //: [textFieldView isAlertViewTextField] == NO)
            [textFieldView isAlertViewTextField] == NO)
        {
            //: [self adjustPosition];
            [self associate];
        }
    }
}

//-(void)editingDidEndOnExit:(UITextField*)textField
//{
//    [self showLog:[NSString stringWithFormat:@"ReturnKey %@",NSStringFromSelector(_cmd)]];
//}

//: #pragma mark - UIStatusBar Notification methods
#pragma mark - UIStatusBar Notification methods
/**  UIApplicationWillChangeStatusBarOrientationNotification. Need to set the textView to it's original position. If any frame changes made. (Bug ID: #92)*/
//: - (void)willChangeStatusBarOrientation:(NSNotification*)aNotification
- (void)complexSentenceUntil:(NSNotification*)aNotification
{
    //: UIInterfaceOrientation currentStatusBarOrientation = UIInterfaceOrientationUnknown;
    UIInterfaceOrientation currentStatusBarOrientation = UIInterfaceOrientationUnknown;


    //: if (@available(iOS 13.0, *))
    if (@available(iOS 13.0, *))
    {
        //: currentStatusBarOrientation = [self keyWindow].windowScene.interfaceOrientation;
        currentStatusBarOrientation = [self theCap].windowScene.interfaceOrientation;
    }
    //: else
    else

    {



    }

//: #pragma clang diagnostic push
#pragma clang diagnostic push
//: #pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
    //: UIInterfaceOrientation statusBarOrientation = [aNotification.userInfo[UIApplicationStatusBarOrientationUserInfoKey] integerValue];
    UIInterfaceOrientation statusBarOrientation = [aNotification.userInfo[UIApplicationStatusBarOrientationUserInfoKey] integerValue];
//: #pragma clang diagnostic pop
#pragma clang diagnostic pop

    //: if (statusBarOrientation != currentStatusBarOrientation)
    if (statusBarOrientation != currentStatusBarOrientation)
    {
        //: return;
        return;
    }

    //: CFTimeInterval startTime = CACurrentMediaTime();
    CFTimeInterval startTime = CACurrentMediaTime();
    //: [self showLog:[NSString stringWithFormat:@">>>>> %@ started >>>>>",NSStringFromSelector(_cmd)] indentation:1];
    [self take:[NSString stringWithFormat:[MassiveEmergencyData componentPublisherPlatform],NSStringFromSelector(_cmd)] message:1];

    //: [self showLog:[NSString stringWithFormat:@"Notification Object: %@", NSStringFromClass([aNotification.object class])]];
    [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData commonTradeValue], NSStringFromClass([aNotification.object class])]];

    //: __strong __typeof__(UIView) *strongTextFieldView = _textFieldView;
    __strong __typeof__(UIView) *strongTextFieldView = _textFieldView;

    //If textViewContentInsetChanged is changed then restore it.
    //: if (_isTextViewContentInsetChanged == YES &&
    if (_isTextViewContentInsetChanged == YES &&
        //: [strongTextFieldView respondsToSelector:@selector(isEditable)] && [strongTextFieldView isKindOfClass:[UIScrollView class]])
        [strongTextFieldView respondsToSelector:@selector(isEditable)] && [strongTextFieldView isKindOfClass:[UIScrollView class]])
    {
        //: UIScrollView *textView = (UIScrollView*)strongTextFieldView;
        UIScrollView *textView = (UIScrollView*)strongTextFieldView;
        //: self.isTextViewContentInsetChanged = NO;
        self.isTextViewContentInsetChanged = NO;
	[self setCorrect:_operation];
        //: if (UIEdgeInsetsEqualToEdgeInsets(textView.contentInset, self.startingTextViewContentInsets) == NO)
        if (UIEdgeInsetsEqualToEdgeInsets(textView.contentInset, self.startingTextViewContentInsets) == NO)
        {
            //: __weak __typeof__(self) weakSelf = self;
            __weak __typeof__(self) weakSelf = self;

            //Due to orientation callback we need to set it's original position.
            //: [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{
            [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{

                //: __strong __typeof__(self) strongSelf = weakSelf;
                __strong __typeof__(self) strongSelf = weakSelf;

                //: [strongSelf showLog:[NSString stringWithFormat:@"Restoring textView.contentInset to : %@",NSStringFromUIEdgeInsets(strongSelf.startingTextViewContentInsets)]];
                [strongSelf prepareLog:[NSString stringWithFormat:[MassiveEmergencyData featureFreshSoftwareMessage],NSStringFromUIEdgeInsets(strongSelf.startingTextViewContentInsets)]];

                //Setting textField to it's initial contentInset
                //: textView.contentInset = strongSelf.startingTextViewContentInsets;
                textView.contentInset = strongSelf.startingTextViewContentInsets;
                //: textView.scrollIndicatorInsets = strongSelf.startingTextViewScrollIndicatorInsets;
                textView.scrollIndicatorInsets = strongSelf.startingTextViewScrollIndicatorInsets;
            //: } completion:NULL];
            } completion:NULL];
        }
    }

    //: [self restorePosition];
    [self juxtaposition];

    //: CFTimeInterval elapsedTime = CACurrentMediaTime() - startTime;
    CFTimeInterval elapsedTime = CACurrentMediaTime() - startTime;
    //: [self showLog:[NSString stringWithFormat:@"<<<<< %@ ended: %g seconds <<<<<",NSStringFromSelector(_cmd),elapsedTime] indentation:-1];
    [self take:[NSString stringWithFormat:[MassiveEmergencyData styleWayPlatform],NSStringFromSelector(_cmd),elapsedTime] message:-1];
}

/** Remove any toolbar if it is PreviousUnctionToolbar. */
//: -(void)removeToolbarIfRequired 
-(void)cap //  (Bug ID: #18)
{
    //: CFTimeInterval startTime = CACurrentMediaTime();
    CFTimeInterval startTime = CACurrentMediaTime();
    //: [self showLog:[NSString stringWithFormat:@">>>>> %@ started >>>>>",NSStringFromSelector(_cmd)] indentation:1];
    [self take:[NSString stringWithFormat:[MassiveEmergencyData componentPublisherPlatform],NSStringFromSelector(_cmd)] message:1];

    //    Getting all the sibling textFields.
    //: NSArray<UIView*> *siblings = [self responderViews];
    NSArray<UIView*> *siblings = [self beforeTo];

    //: [self showLog:[NSString stringWithFormat:@"Found %lu responder sibling(s)",(unsigned long)siblings.count]];
    [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData widgetEstimatePage],(unsigned long)siblings.count]];

    //: for (UITextField *textField in siblings)
    for (UITextField *textField in siblings)
    {
        //: UIView *toolbar = [textField inputAccessoryView];
        UIView *toolbar = [textField inputAccessoryView];

        //  (Bug ID: #78)
        //setInputAccessoryView: check   (Bug ID: #307)
        //: if ([textField respondsToSelector:@selector(setInputAccessoryView:)] &&
        if ([textField respondsToSelector:@selector(setInputAccessoryView:)] &&
            //: ([toolbar isKindOfClass:[IQToolbar class]] && (toolbar.tag == kIQDoneButtonToolbarTag || toolbar.tag == kIQPreviousNextButtonToolbarTag)))
            ([toolbar isKindOfClass:[PreviousUnctionToolbar class]] && (toolbar.tag == featureResultPath(nil) || toolbar.tag == appShareValue(nil))))
        {
            //: textField.inputAccessoryView = nil;
            textField.inputAccessoryView = nil;
	[self setArea:_topViewBeginSafeAreaInsets];
            //: [textField reloadInputViews];
            [textField reloadInputViews];
        }
    }

    //: CFTimeInterval elapsedTime = CACurrentMediaTime() - startTime;
    CFTimeInterval elapsedTime = CACurrentMediaTime() - startTime;
    //: [self showLog:[NSString stringWithFormat:@"<<<<< %@ ended: %g seconds <<<<<",NSStringFromSelector(_cmd),elapsedTime] indentation:-1];
    [self take:[NSString stringWithFormat:[MassiveEmergencyData styleWayPlatform],NSStringFromSelector(_cmd),elapsedTime] message:-1];
}

- (NSString *)christianYear:(NSString *)primary {
    //: OC_CUSTOM_PROPERTY_INJECT
    _primary = primary;
    return primary;
}

/** Enable/disable autoToolbar. Adding and removing toolbar if required. */
//: -(void)setEnableAutoToolbar:(BOOL)enableAutoToolbar
-(void)setEnableAutoToolbar:(BOOL)enableAutoToolbar
{
    //: _enableAutoToolbar = enableAutoToolbar;
    _precedency = enableAutoToolbar;
	[self setPrefer:_my];

    //: [self showLog:[NSString stringWithFormat:@"enableAutoToolbar: %@",enableAutoToolbar?@"Yes":@"No"]];
    [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData colorCurateName],enableAutoToolbar?[MassiveEmergencyData themeBoostPath]:[MassiveEmergencyData appRuleConfig]]];

    //If enabled then adding toolbar.
    //: if ([self privateIsEnableAutoToolbar] == YES)
    if ([self validRow] == YES)
    {
        //: [self addToolbarIfRequired];
        [self direct];
    }
    //Else removing toolbar.
    //: else
    else
    {
        //: [self removeToolbarIfRequired];
        [self cap];
    }
}

/**
 Remove customized Notification for third party customized TextField/TextView.
 */
//: -(void)unregisterTextFieldViewClass:(nonnull Class)aClass
-(void)marque:(nonnull Class)aClass
    //: didBeginEditingNotificationName:(nonnull NSString *)didBeginEditingNotificationName
    parentName:(nonnull NSString *)didBeginEditingNotificationName
      //: didEndEditingNotificationName:(nonnull NSString *)didEndEditingNotificationName
      creditNext:(nonnull NSString *)didEndEditingNotificationName
{
    //: [[NSNotificationCenter defaultCenter] removeObserver:self name:didBeginEditingNotificationName object:nil];
    [[NSNotificationCenter defaultCenter] removeObserver:self name:didBeginEditingNotificationName object:nil];
    //: [[NSNotificationCenter defaultCenter] removeObserver:self name:didEndEditingNotificationName object:nil];
    [[NSNotificationCenter defaultCenter] removeObserver:self name:didEndEditingNotificationName object:nil];
}

//: -(void)showLog:(NSString*)logString indentation:(NSInteger)indent
-(void)take:(NSString*)logString message:(NSInteger)indent
{
    //: static NSInteger indentation = 0;
    static NSInteger indentation = 0;

    //: if (indent < 0)
    if (indent < 0)
    {
        //: indentation = ((0) > (indentation + indent) ? (0) : (indentation + indent));
        indentation = ((0) > (indentation + indent) ? (0) : (indentation + indent));
	[self setPrimary:_toolbarDoneBarButtonItemAccessibilityLabel];
    }

    //: if (_enableDebugging)
    if (_enableDebugging)
    {
        //: NSMutableString *preLog = [[NSMutableString alloc] init];
        NSMutableString *preLog = [[NSMutableString alloc] init];

        //: for (int i = 0; i<=indentation; i++)
        for (int i = 0; i<=indentation; i++)
        {
            //: [preLog appendString:@"|\t"];
            [preLog appendString:@"|\t"];
        }

        //: [preLog appendString:logString];
        [preLog appendString:logString];
        //: NSLog(@"%@",preLog);
    }

    //: if (indent > 0)
    if (indent > 0)
    {
        //: indentation += indent;
        indentation += indent;
    }
}

/** Returns YES if can navigate to next responder textField/textView, otherwise NO. */
//: -(BOOL)canGoNext
-(BOOL)canGoNext
{
    //Getting all responder view's.
    //: NSArray<UIView*> *textFields = [self responderViews];
    NSArray<UIView*> *textFields = [self beforeTo];

    //Getting index of current textField.
    //: NSUInteger index = [textFields indexOfObject:_textFieldView];
    NSUInteger index = [textFields indexOfObject:_textFieldView];

    //If it is not last textField. then it's next object becomeFirstResponder.
    //: if (index != NSNotFound &&
    if (index != NSNotFound &&
        //: index < textFields.count-1)
        index < textFields.count-1)
    {
        //: return YES;
        return YES;
    }
    //: else
    else
    {
        //: return NO;
        return NO;
    }
}

- (UIImage *)existent:(UIImage *)addition {
    //: OC_CUSTOM_PROPERTY_INJECT
    _addition = addition;
    return addition;
}

//: #pragma mark - Private Methods
#pragma mark - Private Methods

/** Getting keyWindow. */
//: -(UIWindow *)keyWindow
-(UIWindow *)theCap
{
    //: UIView *textFieldView = _textFieldView;
    UIView *textFieldView = _textFieldView;

    //: if (textFieldView.window)
    if (textFieldView.window)
    {
        //: return textFieldView.window;
        return textFieldView.window;
    }
    //: else
    else
    {
        //: static __weak UIWindow *cachedKeyWindow = nil;
        static __weak UIWindow *cachedKeyWindow = nil;

        /*  (Bug ID: #23, #25, #73)   */
        //: UIWindow *originalKeyWindow = nil;
        UIWindow *originalKeyWindow = nil;


        //: if (@available(iOS 13.0, *))
        if (@available(iOS 13.0, *))
        {
            //: NSSet<UIScene *> *connectedScenes = [UIApplication sharedApplication].connectedScenes;
            NSSet<UIScene *> *connectedScenes = [UIApplication sharedApplication].connectedScenes;
            //: for (UIScene *scene in connectedScenes)
            for (UIScene *scene in connectedScenes)
            {
                //: if (scene.activationState == UISceneActivationStateForegroundActive && [scene isKindOfClass:[UIWindowScene class]])
                if (scene.activationState == UISceneActivationStateForegroundActive && [scene isKindOfClass:[UIWindowScene class]])
                {
                    //: UIWindowScene *windowScene = (UIWindowScene *)scene;
                    UIWindowScene *windowScene = (UIWindowScene *)scene;
                    //: for (UIWindow *window in windowScene.windows)
                    for (UIWindow *window in windowScene.windows)
                    {
                        //: if (window.isKeyWindow)
                        if (window.isKeyWindow)
                        {
                            //: originalKeyWindow = window;
                            originalKeyWindow = window;
	[self setPrimary:_toolbarDoneBarButtonItemAccessibilityLabel];
                            //: break;
                            break;
                        }
                    }
                }
            }
        }
        //: else
        else

        {



        }

        //If original key window is not nil and the cached keyWindow is also not original keyWindow then changing keyWindow.
        //: if (originalKeyWindow)
        if (originalKeyWindow)
        {
            //: cachedKeyWindow = originalKeyWindow;
            cachedKeyWindow = originalKeyWindow;
        }

        //: __strong UIWindow *strongCachedKeyWindow = cachedKeyWindow;
        __strong UIWindow *strongCachedKeyWindow = cachedKeyWindow;

        //: return strongCachedKeyWindow;
        return strongCachedKeyWindow;
    }
}

- (UIViewController *)noActive:(UIViewController *)sortActive {
    //: OC_CUSTOM_PROPERTY_INJECT
    _sortActive = sortActive;
    return sortActive;
}

//: #pragma mark AutoResign methods
#pragma mark AutoResign methods

/** Resigning on tap gesture. */
//: - (void)tapRecognized:(UITapGestureRecognizer*)gesture 
- (void)withDirection:(UITapGestureRecognizer*)gesture // (Enhancement ID: #14)
{
    //: if (gesture.state == UIGestureRecognizerStateEnded)
    if (gesture.state == UIGestureRecognizerStateEnded)
    {
        //Resigning currently responder textField.
        //: [self resignFirstResponder];
        [self formatResponder];
    }
}

//: -(void)registerKeyboardSizeChangeWithIdentifier:(nonnull id<NSCopying>)identifier sizeHandler:(void (^_Nonnull)(CGSize size))sizeHandler
-(void)sizePad:(nonnull id<NSCopying>)identifier picture:(void (^_Nonnull)(CGSize size))sizeHandler
{
    //: _keyboardSizeObservers[identifier] = sizeHandler;
    _exclude[identifier] = sizeHandler;
	[self setPrimary:_toolbarDoneBarButtonItemAccessibilityLabel];
}

/** To not detect touch events in a subclass of UIControl, these may have added their own selector for specific work */
//: -(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch
-(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch
{
    //  Should not recognize gesture if the clicked view is either UIControl or UINavigationBar(<Back button etc...)    (Bug ID: #145)
    //: for (Class aClass in self.touchResignedGestureIgnoreClasses)
    for (Class aClass in self.touchResignedGestureIgnoreClasses)
    {
        //: if ([[touch view] isKindOfClass:aClass])
        if ([[touch view] isKindOfClass:aClass])
        {
            //: return NO;
            return NO;
        }
    }

    //: return YES;
    return YES;
}

//: -(void)restorePosition
-(void)juxtaposition
{
    //  Setting rootViewController frame to it's original position. //  (Bug ID: #18)
    //: if (_rootViewController && __CGPointEqualToPoint(_topViewBeginOrigin, CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308)) == false)
    if (_rootViewController && __CGPointEqualToPoint(_topViewBeginOrigin, CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308)) == false)
    {
        //: __weak __typeof__(self) weakSelf = self;
        __weak __typeof__(self) weakSelf = self;

        //Used UIViewAnimationOptionBeginFromCurrentState to minimize strange animations.
        //: [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{
        [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{

            //: __strong __typeof__(self) strongSelf = weakSelf;
            __strong __typeof__(self) strongSelf = weakSelf;
            //: UIViewController *strongRootController = strongSelf.rootViewController;
            UIViewController *strongRootController = [self makerRefresh:strongSelf.rootViewController];

            {
                //: [strongSelf showLog:[NSString stringWithFormat:@"Restoring %@ origin to : %@", NSStringFromClass([strongRootController class]), NSStringFromCGPoint(strongSelf.topViewBeginOrigin)]];
                [strongSelf prepareLog:[NSString stringWithFormat:[MassiveEmergencyData featureRoveConfig], NSStringFromClass([strongRootController class]), NSStringFromCGPoint(strongSelf.topViewBeginOrigin)]];

                //Restoring
                //: CGRect rect = strongRootController.view.frame;
                CGRect rect = strongRootController.view.frame;
                //: rect.origin = strongSelf.topViewBeginOrigin;
                rect.origin = strongSelf.topViewBeginOrigin;
                //: strongRootController.view.frame = rect;
                strongRootController.view.frame = rect;

                //: strongSelf.movedDistance = 0;
                strongSelf.movedDistance = 0;

                //: if (strongRootController.navigationController.interactivePopGestureRecognizer.state == UIGestureRecognizerStateBegan)
                if (strongRootController.navigationController.interactivePopGestureRecognizer.state == UIGestureRecognizerStateBegan)
                {
                    //: strongSelf.rootViewControllerWhilePopGestureRecognizerActive = strongRootController;
                    strongSelf.rootViewControllerWhilePopGestureRecognizerActive = strongRootController;
                    //: strongSelf.topViewBeginOriginWhilePopGestureRecognizerActive = strongSelf.topViewBeginOrigin;
                    strongSelf.topViewBeginOriginWhilePopGestureRecognizerActive = strongSelf.topViewBeginOrigin;
                }

                //Animating content if needed (Bug ID: #204)
                //: if (strongSelf.layoutIfNeededOnUpdate)
                if (strongSelf.layoutIfNeededOnUpdate)
                {
                    //Animating content (Bug ID: #160)
                    //: [strongRootController.view setNeedsLayout];
                    [strongRootController.view setNeedsLayout];
                    //: [strongRootController.view layoutIfNeeded];
                    [strongRootController.view layoutIfNeeded];
                }
            }

        //: } completion:NULL];
        } completion:NULL];
        //: _rootViewController = nil;
        _rootViewController = nil;
	[self setAddition:_toolbarPreviousBarButtonItemImage];
    }
}

- (UIEdgeInsets)adjustmentArea:(UIEdgeInsets)area {
    //: OC_CUSTOM_PROPERTY_INJECT
    _area = area;
    return area;
}

/** Setter of movedDistance property. */
//: -(void)setMovedDistance:(CGFloat)movedDistance
-(void)setMovedDistance:(CGFloat)movedDistance
{
    //: _movedDistance = movedDistance;
    _movedDistance = movedDistance;
	[self setPrimary:_toolbarDoneBarButtonItemAccessibilityLabel];
    //: if (self.movedDistanceChanged != nil)
    if (self.movedDistanceChanged != nil)
    {
        //: self.movedDistanceChanged(movedDistance);
        self.movedDistanceChanged(movedDistance);
    }
}

/*  Automatically called from the `+(void)load` method. */
//: + (IQKeyboardManager*)sharedManager
+ (StickBrief*)playCreation
{
 //Singleton instance
 //: static IQKeyboardManager *kbManager;
 static StickBrief *kbManager;

 //: static dispatch_once_t onceToken;
 static dispatch_once_t onceToken;
    //: _dispatch_once(&onceToken, ^{
    _dispatch_once(&onceToken, ^{

        //: kbManager = [[self alloc] init];
        kbManager = [[self alloc] init];
    //: });
    });

 //: return kbManager;
 return kbManager;
}

//: #pragma mark - Property functions
#pragma mark - Property functions
//: -(void)setEnable:(BOOL)enable
-(void)setEnable:(BOOL)enable
{
 // If not enabled, enable it.
    //: if (enable == YES &&
    if (enable == YES &&
        //: _enable == NO)
        _latchkeyOn == NO)
    {
  //Setting YES to _enable.
  //: _enable = enable;
  _latchkeyOn = enable;
	[self setArea:_topViewBeginSafeAreaInsets];

  //If keyboard is currently showing. Sending a fake notification for keyboardWillShow to adjust view according to keyboard.
  //: if (_kbShowNotification) [self keyboardWillShow:_kbShowNotification];
  if (_preexist) [self reportTrigger:_preexist];

        //: [self showLog:@"Enabled"];
        [self prepareLog:[MassiveEmergencyData styleAluminumDevice]];
    }
 //If not disable, disable it.
    //: else if (enable == NO &&
    else if (enable == NO &&
             //: _enable == YES)
             _latchkeyOn == YES)
    {
  //Sending a fake notification for keyboardWillHide to retain view's original position.
  //: [self keyboardWillHide:nil];
  [self afterGravity:nil];

  //Setting NO to _enable.
  //: _enable = enable;
  _latchkeyOn = enable;

        //: [self showLog:@"Disabled"];
        [self prepareLog:[MassiveEmergencyData appKindSettings]];
    }
 //If already disabled.
 //: else if (enable == NO &&
 else if (enable == NO &&
             //: _enable == NO)
             _latchkeyOn == NO)
 {
        //: [self showLog:@"Already Disabled"];
        [self prepareLog:[MassiveEmergencyData themeLateDelicateFormat]];
 }
 //If already enabled.
 //: else if (enable == YES &&
 else if (enable == YES &&
             //: _enable == YES)
             _latchkeyOn == YES)
 {
        //: [self showLog:@"Already Enabled"];
        [self prepareLog:[MassiveEmergencyData layoutGovernPage]];
 }
}

/**    reloadInputViews to reload toolbar buttons enable/disable state on the fly Enhancement ID #434. */
//: - (void)reloadInputViews
- (void)related
{
    //If enabled then adding toolbar.
    //: if ([self privateIsEnableAutoToolbar] == YES)
    if ([self validRow] == YES)
    {
        //: [self addToolbarIfRequired];
        [self direct];
    }
    //Else removing toolbar.
    //: else
    else
    {
        //: [self removeToolbarIfRequired];
        [self cap];
    }
}

//: -(BOOL)privateShouldResignOnTouchOutside
-(BOOL)acceptableOutside
{
    //: BOOL shouldResignOnTouchOutside = _shouldResignOnTouchOutside;
    BOOL shouldResignOnTouchOutside = _familyOutside;

    //: __strong __typeof__(UIView) *strongTextFieldView = _textFieldView;
    __strong __typeof__(UIView) *strongTextFieldView = _textFieldView;

    //: IQEnableMode enableMode = strongTextFieldView.shouldResignOnTouchOutsideMode;
    IQEnableMode enableMode = strongTextFieldView.shouldResignOnTouchOutsideMode;

    //: if (enableMode == IQEnableModeEnabled)
    if (enableMode == IQEnableModeEnabled)
    {
        //: shouldResignOnTouchOutside = YES;
        shouldResignOnTouchOutside = YES;
    }
    //: else if (enableMode == IQEnableModeDisabled)
    else if (enableMode == IQEnableModeDisabled)
    {
        //: shouldResignOnTouchOutside = NO;
        shouldResignOnTouchOutside = NO;
    }
    //: else
    else
    {
        //: UIViewController *textFieldViewController = [strongTextFieldView viewContainingController];
        UIViewController *textFieldViewController = [strongTextFieldView viewContainingController];

        //: if (textFieldViewController)
        if (textFieldViewController)
        {
            //If it is searchBar textField embedded in Navigation Bar
            //: if ([strongTextFieldView textFieldSearchBar] != nil && [textFieldViewController isKindOfClass:[UINavigationController class]])
            if ([strongTextFieldView textFieldSearchBar] != nil && [textFieldViewController isKindOfClass:[UINavigationController class]])
            {
                //: UINavigationController *navController = (UINavigationController*)textFieldViewController;
                UINavigationController *navController = (UINavigationController*)textFieldViewController;
                //: if (navController.topViewController)
                if (navController.topViewController)
                {
                    //: textFieldViewController = navController.topViewController;
                    textFieldViewController = navController.topViewController;
	[self setStarting:_startingScrollIndicatorInsets];
                }
            }

            //: if (shouldResignOnTouchOutside == NO)
            if (shouldResignOnTouchOutside == NO)
            {
                //If viewController is kind of enable viewController class, then assuming shouldResignOnTouchOutside is enabled.
                //: for (Class enabledClass in _enabledTouchResignedClasses)
                for (Class enabledClass in _enabledTouchResignedClasses)
                {
                    //: if ([textFieldViewController isKindOfClass:enabledClass])
                    if ([textFieldViewController isKindOfClass:enabledClass])
                    {
                        //: shouldResignOnTouchOutside = YES;
                        shouldResignOnTouchOutside = YES;
                        //: break;
                        break;
                    }
                }
            }

            //: if (shouldResignOnTouchOutside)
            if (shouldResignOnTouchOutside)
            {
                //If viewController is kind of disable viewController class, then assuming shouldResignOnTouchOutside is disable.
                //: for (Class disabledClass in _disabledTouchResignedClasses)
                for (Class disabledClass in _disabledTouchResignedClasses)
                {
                    //: if ([textFieldViewController isKindOfClass:disabledClass])
                    if ([textFieldViewController isKindOfClass:disabledClass])
                    {
                        //: shouldResignOnTouchOutside = NO;
                        shouldResignOnTouchOutside = NO;
	[self setPrefer:_my];
                        //: break;
                        break;
                    }
                }

                //Special Controllers
                //: if (shouldResignOnTouchOutside == YES)
                if (shouldResignOnTouchOutside == YES)
                {
                    //: NSString *classNameString = NSStringFromClass([textFieldViewController class]);
                    NSString *classNameString = NSStringFromClass([textFieldViewController class]);

                    //_UIAlertControllerTextFieldViewController
                    //: if ([classNameString containsString:@"UIAlertController"] && [classNameString hasSuffix:@"TextFieldViewController"])
                    if ([classNameString containsString:@"UIAlertController"] && [classNameString hasSuffix:[MassiveEmergencyData widgetHoldValue]])
                    {
                        //: shouldResignOnTouchOutside = NO;
                        shouldResignOnTouchOutside = NO;
	[self setAddition:_toolbarPreviousBarButtonItemImage];
                    }
                }
            }
        }
    }

    //: return shouldResignOnTouchOutside;
    return shouldResignOnTouchOutside;
}

/** Add toolbar if it is required to add on textFields and it's siblings. */
//: -(void)addToolbarIfRequired
-(void)direct
{
    //: CFTimeInterval startTime = CACurrentMediaTime();
    CFTimeInterval startTime = CACurrentMediaTime();
    //: [self showLog:[NSString stringWithFormat:@">>>>> %@ started >>>>>",NSStringFromSelector(_cmd)] indentation:1];
    [self take:[NSString stringWithFormat:[MassiveEmergencyData componentPublisherPlatform],NSStringFromSelector(_cmd)] message:1];

    //    Getting all the sibling textFields.
    //: NSArray<UIView*> *siblings = [self responderViews];
    NSArray<UIView*> *siblings = [self beforeTo];

    //: [self showLog:[NSString stringWithFormat:@"Found %lu responder sibling(s)",(unsigned long)siblings.count]];
    [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData widgetEstimatePage],(unsigned long)siblings.count]];

    //: UIView *textFieldView = _textFieldView;
    UIView *textFieldView = _textFieldView;

    //Either there is no inputAccessoryView or if accessoryView is not appropriate for current situation(There is Previous/Next/Done toolbar).
    //setInputAccessoryView: check   (Bug ID: #307)
    //: if ([textFieldView respondsToSelector:@selector(setInputAccessoryView:)])
    if ([textFieldView respondsToSelector:@selector(setInputAccessoryView:)])
    {
        //: if ([textFieldView inputAccessoryView] == nil ||
        if ([textFieldView inputAccessoryView] == nil ||
            //: [[textFieldView inputAccessoryView] tag] == kIQPreviousNextButtonToolbarTag ||
            [[textFieldView inputAccessoryView] tag] == appShareValue(nil) ||
            //: [[textFieldView inputAccessoryView] tag] == kIQDoneButtonToolbarTag)
            [[textFieldView inputAccessoryView] tag] == featureResultPath(nil))
        {
            //: UITextField *textField = (UITextField*)textFieldView;
            UITextField *textField = (UITextField*)textFieldView;

            //: IQBarButtonItemConfiguration *rightConfiguration = nil;
            FixingSave *rightConfiguration = nil;

            //Supporting Custom Done button image (Enhancement ID: #366)
            //: if (_toolbarDoneBarButtonItemImage)
            if (_toolbarDoneBarButtonItemImage)
            {
                //: rightConfiguration = [[IQBarButtonItemConfiguration alloc] initWithImage:_toolbarDoneBarButtonItemImage action:@selector(doneAction:)];
                rightConfiguration = [[FixingSave alloc] initWithRedAction:_toolbarDoneBarButtonItemImage my:@selector(ring:)];
            }
            //Supporting Custom Done button text (Enhancement ID: #209, #411, Bug ID: #376)
            //: else if (_toolbarDoneBarButtonItemText)
            else if (_toolbarDoneBarButtonItemText)
            {
                //: rightConfiguration = [[IQBarButtonItemConfiguration alloc] initWithTitle:_toolbarDoneBarButtonItemText action:@selector(doneAction:)];
                rightConfiguration = [[FixingSave alloc] initWithInformation:_toolbarDoneBarButtonItemText over:@selector(ring:)];
            }
            //: else
            else
            {
                //: rightConfiguration = [[IQBarButtonItemConfiguration alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemDone action:@selector(doneAction:)];
                rightConfiguration = [[FixingSave alloc] initWithRawTool:UIBarButtonSystemItemDone month:@selector(ring:)];
            }
            //: rightConfiguration.accessibilityLabel = _toolbarDoneBarButtonItemAccessibilityLabel ? : @"Done";
            rightConfiguration.accessibilityLabel = [self christianYear:_toolbarDoneBarButtonItemAccessibilityLabel] ? : [MassiveEmergencyData moduleHoldPlatform];
	[self setSortActive:_rootViewControllerWhilePopGestureRecognizerActive];

            //: BOOL isTableCollectionView = NO;
            BOOL isTableCollectionView = NO;
            //: if ([textFieldView superviewOfClassType:[UITableView class]] != nil
            if ([textFieldView down:[UITableView class]] != nil
                //: || [textFieldView superviewOfClassType:[UICollectionView class]] != nil)
                || [textFieldView down:[UICollectionView class]] != nil)
            {
                //: isTableCollectionView = YES;
                isTableCollectionView = YES;
            }
            //: else
            else
            {
                //: isTableCollectionView = NO;
                isTableCollectionView = NO;
	[self setPrefer:_my];
            }

            //: BOOL havePreviousNext = NO;
            BOOL havePreviousNext = NO;
            //: switch (self.previousNextDisplayMode)
            switch (self.previousNextDisplayMode)
            {
                //: case IQPreviousNextDisplayModeDefault:
                case IQPreviousNextDisplayModeDefault:
                    //: if (isTableCollectionView)
                    if (isTableCollectionView)
                    {
                        //: havePreviousNext = YES;
                        havePreviousNext = YES;
	[self setSortActive:_rootViewControllerWhilePopGestureRecognizerActive];
                    }
                    //: else if (siblings.count <= 1)
                    else if (siblings.count <= 1)
                    {
                        //: havePreviousNext = NO;
                        havePreviousNext = NO;
	[self setArea:_topViewBeginSafeAreaInsets];
                    }
                    //: else
                    else
                    {
                        //: havePreviousNext = YES;
                        havePreviousNext = YES;
	[self setSortActive:_rootViewControllerWhilePopGestureRecognizerActive];
                    }
                    //: break;
                    break;
                //: case IQPreviousNextDisplayModeAlwaysShow:
                case IQPreviousNextDisplayModeAlwaysShow:
                    //: havePreviousNext = YES;
                    havePreviousNext = YES;
                    //: break;
                    break;
                //: case IQPreviousNextDisplayModeAlwaysHide:
                case IQPreviousNextDisplayModeAlwaysHide:
                    //: havePreviousNext = NO;
                    havePreviousNext = NO;
                    //: break;
                    break;
            }

            //: if (havePreviousNext)
            if (havePreviousNext)
            {
                //: IQBarButtonItemConfiguration *prevConfiguration = nil;
                FixingSave *prevConfiguration = nil;

                //Supporting Custom Done button image (Enhancement ID: #366)
                //: if (_toolbarPreviousBarButtonItemImage)
                if ([self existent:_toolbarPreviousBarButtonItemImage])
                {
                    //: prevConfiguration = [[IQBarButtonItemConfiguration alloc] initWithImage:_toolbarPreviousBarButtonItemImage action:@selector(previousAction:)];
                    prevConfiguration = [[FixingSave alloc] initWithRedAction:_toolbarPreviousBarButtonItemImage my:@selector(bubbling:)];
                }
                //Supporting Custom Done button text (Enhancement ID: #209, #411, Bug ID: #376)
                //: else if (_toolbarPreviousBarButtonItemText)
                else if (_toolbarPreviousBarButtonItemText)
                {
                    //: prevConfiguration = [[IQBarButtonItemConfiguration alloc] initWithTitle:_toolbarPreviousBarButtonItemText action:@selector(previousAction:)];
                    prevConfiguration = [[FixingSave alloc] initWithInformation:_toolbarPreviousBarButtonItemText over:@selector(bubbling:)];
	[self setStarting:_startingScrollIndicatorInsets];
                }
                //: else
                else
                {
                    //: prevConfiguration = [[IQBarButtonItemConfiguration alloc] initWithImage:[UIImage keyboardPreviousImage] action:@selector(previousAction:)];
                    prevConfiguration = [[FixingSave alloc] initWithRedAction:[UIImage reason] my:@selector(bubbling:)];
	[self setSpecialController:_rootViewController];
                }
                //: prevConfiguration.accessibilityLabel = _toolbarPreviousBarButtonItemAccessibilityLabel ? : @"Previous";
                prevConfiguration.accessibilityLabel = _toolbarPreviousBarButtonItemAccessibilityLabel ? : [MassiveEmergencyData kTurnKey];
	[self setArea:_topViewBeginSafeAreaInsets];

                //: IQBarButtonItemConfiguration *nextConfiguration = nil;
                FixingSave *nextConfiguration = nil;

                //Supporting Custom Done button image (Enhancement ID: #366)
                //: if (_toolbarNextBarButtonItemImage)
                if (_toolbarNextBarButtonItemImage)
                {
                    //: nextConfiguration = [[IQBarButtonItemConfiguration alloc] initWithImage:_toolbarNextBarButtonItemImage action:@selector(nextAction:)];
                    nextConfiguration = [[FixingSave alloc] initWithRedAction:_toolbarNextBarButtonItemImage my:@selector(coverred:)];
                }
                //Supporting Custom Done button text (Enhancement ID: #209, #411, Bug ID: #376)
                //: else if (_toolbarNextBarButtonItemText)
                else if (_toolbarNextBarButtonItemText)
                {
                    //: nextConfiguration = [[IQBarButtonItemConfiguration alloc] initWithTitle:_toolbarNextBarButtonItemText action:@selector(nextAction:)];
                    nextConfiguration = [[FixingSave alloc] initWithInformation:_toolbarNextBarButtonItemText over:@selector(coverred:)];
                }
                //: else
                else
                {
                    //: nextConfiguration = [[IQBarButtonItemConfiguration alloc] initWithImage:[UIImage keyboardNextImage] action:@selector(nextAction:)];
                    nextConfiguration = [[FixingSave alloc] initWithRedAction:[UIImage keyboardVariety] my:@selector(coverred:)];
	[self setSpecialController:_rootViewController];
                }
                //: nextConfiguration.accessibilityLabel = _toolbarNextBarButtonItemAccessibilityLabel ? : @"Next";
                nextConfiguration.accessibilityLabel = _toolbarNextBarButtonItemAccessibilityLabel ? : [MassiveEmergencyData spacingLeasedId];

                //: [textField addKeyboardToolbarWithTarget:self titleText:(_shouldShowToolbarPlaceholder ? textField.drawingToolbarPlaceholder : nil) rightBarButtonConfiguration:rightConfiguration previousBarButtonConfiguration:prevConfiguration nextBarButtonConfiguration:nextConfiguration];
                [textField dismissConfiguration:self flexible:(_inputFront ? textField.drawingToolbarPlaceholder : nil) buttonFillConfiguration:rightConfiguration language:prevConfiguration displayPrepare:nextConfiguration];

                //: textField.inputAccessoryView.tag = kIQPreviousNextButtonToolbarTag; 
                textField.inputAccessoryView.tag = appShareValue(nil); //  (Bug ID: #78)

                //: if (isTableCollectionView)
                if (isTableCollectionView)
                {
                    // In case of UITableView (Special), the next/previous buttons should always be enabled.    (Bug ID: #56)
                    //: textField.keyboardToolbar.previousBarButton.enabled = YES;
                    textField.keyboardToolbar.previousBarButton.enabled = YES;
                    //: textField.keyboardToolbar.nextBarButton.enabled = YES;
                    textField.keyboardToolbar.nextBarButton.enabled = YES;
	[self setSortActive:_rootViewControllerWhilePopGestureRecognizerActive];
                }
                //: else
                else
                {
                    // If firstTextField, then previous should not be enabled.
                    //: textField.keyboardToolbar.previousBarButton.enabled = (siblings.firstObject != textField);
                    textField.keyboardToolbar.previousBarButton.enabled = (siblings.firstObject != textField);
                    // If lastTextField then next should not be enabled.
                    //: textField.keyboardToolbar.nextBarButton.enabled = (siblings.lastObject != textField);
                    textField.keyboardToolbar.nextBarButton.enabled = (siblings.lastObject != textField);
                }
            }
            //: else
            else
            {
                //: [textField addKeyboardToolbarWithTarget:self titleText:(_shouldShowToolbarPlaceholder ? textField.drawingToolbarPlaceholder : nil) rightBarButtonConfiguration:rightConfiguration previousBarButtonConfiguration:nil nextBarButtonConfiguration:nil];
                [textField dismissConfiguration:self flexible:(_inputFront ? textField.drawingToolbarPlaceholder : nil) buttonFillConfiguration:rightConfiguration language:nil displayPrepare:nil];

                //: textField.inputAccessoryView.tag = kIQDoneButtonToolbarTag; 
                textField.inputAccessoryView.tag = featureResultPath(nil);
	[self setSortActive:_rootViewControllerWhilePopGestureRecognizerActive]; //  (Bug ID: #78)
            }

            //: IQToolbar *toolbar = textField.keyboardToolbar;
            PreviousUnctionToolbar *toolbar = textField.keyboardToolbar;

            //Bar style according to keyboard appearance
            //: if ([textField respondsToSelector:@selector(keyboardAppearance)])
            if ([textField respondsToSelector:@selector(keyboardAppearance)])
            {
                //Setting toolbar tintColor //  (Enhancement ID: #30)
                //: if (_shouldToolbarUsesTextFieldTintColor)
                if (_mobile)
                {
                    //: toolbar.tintColor = [textField tintColor];
                    toolbar.tintColor = [textField tintColor];
                }
                //: else if (_toolbarTintColor)
                else if (_operation)
                {
                    //: toolbar.tintColor = _toolbarTintColor;
                    toolbar.tintColor = _operation;
	[self setCorrect:_operation];
                }
                //: else
                else
                {
                    //: toolbar.tintColor = nil;
                    toolbar.tintColor = nil;
                }

                //: switch ([textField keyboardAppearance])
                switch ([textField keyboardAppearance])
                {
                    //: case UIKeyboardAppearanceDark:
                    case UIKeyboardAppearanceDark:
                    {
                        //: toolbar.barStyle = UIBarStyleBlack;
                        toolbar.barStyle = UIBarStyleBlack;
                        //: [toolbar setBarTintColor:nil];
                        [toolbar setBarTintColor:nil];
                    }
                        //: break;
                        break;
                    //: default:
                    default:
                    {
                        //: toolbar.barStyle = UIBarStyleDefault;
                        toolbar.barStyle = UIBarStyleDefault;
	[self setCorrect:_operation];
                        //: toolbar.barTintColor = _toolbarBarTintColor;
                        toolbar.barTintColor = _pointFoot;
	[self setPrefer:_my];
                    }
                        //: break;
                        break;
                }

                //If need to show placeholder
                //: if (_shouldShowToolbarPlaceholder &&
                if (_inputFront &&
                    //: textField.shouldHideToolbarPlaceholder == NO)
                    textField.shouldHideToolbarPlaceholder == NO)
                {
                    //Updating placeholder     //(Bug ID: #148, #272)
                    //: if (toolbar.titleBarButton.title == nil ||
                    if (toolbar.titleBarButton.title == nil ||
                        //: [toolbar.titleBarButton.title isEqualToString:textField.drawingToolbarPlaceholder] == NO)
                        [toolbar.titleBarButton.title isEqualToString:textField.drawingToolbarPlaceholder] == NO)
                    {
                        //: [toolbar.titleBarButton setTitle:textField.drawingToolbarPlaceholder];
                        [toolbar.titleBarButton setTitle:textField.drawingToolbarPlaceholder];
                    }

                    //Setting toolbar title font.   //  (Enhancement ID: #30)
                    //: if (_placeholderFont &&
                    if (_disableByFont &&
                        //: [_placeholderFont isKindOfClass:[UIFont class]])
                        [_disableByFont isKindOfClass:[UIFont class]])
                    {
                        //: [toolbar.titleBarButton setTitleFont:_placeholderFont];
                        [toolbar.titleBarButton setTitleFont:_disableByFont];
                    }

                    //Setting toolbar title color.   //  (Enhancement ID: #880)
                    //: if (_placeholderColor)
                    if (_minutePlaceholder)
                    {
                        //: [toolbar.titleBarButton setTitleColor:_placeholderColor];
                        [toolbar.titleBarButton setTitleColor:_minutePlaceholder];
                    }

                    //Setting toolbar button title color.   //  (Enhancement ID: #880)
                    //: if (_placeholderButtonColor)
                    if (_fixed)
                    {
                        //: [toolbar.titleBarButton setSelectableTitleColor:_placeholderButtonColor];
                        [toolbar.titleBarButton setSelectableTitleColor:_fixed];
                    }
                }
                //: else
                else
                {
                    //Updating placeholder     //(Bug ID: #272)
                    //: toolbar.titleBarButton.title = nil;
                    toolbar.titleBarButton.title = nil;
	[self setArea:_topViewBeginSafeAreaInsets];
                }
            }
        }
    }

    //: CFTimeInterval elapsedTime = CACurrentMediaTime() - startTime;
    CFTimeInterval elapsedTime = CACurrentMediaTime() - startTime;
    //: [self showLog:[NSString stringWithFormat:@"<<<<< %@ ended: %g seconds <<<<<",NSStringFromSelector(_cmd),elapsedTime] indentation:-1];
    [self take:[NSString stringWithFormat:[MassiveEmergencyData styleWayPlatform],NSStringFromSelector(_cmd),elapsedTime] message:-1];
}

- (BOOL)effectComponent:(BOOL)prefer {
    //: OC_CUSTOM_PROPERTY_INJECT
    _prefer = prefer;
    return prefer;
}


//: -(void)unregisterAllNotifications
-(void)error
{
    //  Unregistering for keyboard notification.
    //: [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillShowNotification object:nil];
    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillShowNotification object:nil];
    //: [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillHideNotification object:nil];
    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillHideNotification object:nil];

    //: [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidBecomeActiveNotification object:nil];
    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidBecomeActiveNotification object:nil];

    //  Unregistering for UITextField notification.
    //: [self unregisterTextFieldViewClass:[UITextField class]
    [self marque:[UITextField class]
     //: didBeginEditingNotificationName:UITextFieldTextDidBeginEditingNotification
     parentName:UITextFieldTextDidBeginEditingNotification
       //: didEndEditingNotificationName:UITextFieldTextDidEndEditingNotification];
       creditNext:UITextFieldTextDidEndEditingNotification];

    //  Unregistering for UITextView notification.
    //: [self unregisterTextFieldViewClass:[UITextView class]
    [self marque:[UITextView class]
     //: didBeginEditingNotificationName:UITextViewTextDidBeginEditingNotification
     parentName:UITextViewTextDidBeginEditingNotification
       //: didEndEditingNotificationName:UITextViewTextDidEndEditingNotification];
       creditNext:UITextViewTextDidEndEditingNotification];

    //  Unregistering for orientation changes notification
//: #pragma clang diagnostic push
#pragma clang diagnostic push
//: #pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
    //: [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationWillChangeStatusBarOrientationNotification object:[UIApplication sharedApplication]];
    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationWillChangeStatusBarOrientationNotification object:[UIApplication sharedApplication]];
//: #pragma clang diagnostic pop
#pragma clang diagnostic pop
}

//: -(void)unregisterKeyboardSizeChangeWithIdentifier:(nonnull id<NSCopying>)identifier
-(void)map:(nonnull id<NSCopying>)identifier
{
    //: _keyboardSizeObservers[identifier] = nil;
    _exclude[identifier] = nil;
	[self setSortActive:_rootViewControllerWhilePopGestureRecognizerActive];
}


//: #pragma mark AutoToolbar methods
#pragma mark AutoToolbar methods

/**    Get all UITextField/UITextView siblings of textFieldView. */
//: -(NSArray<__kindof UIView*>*)responderViews
-(NSArray<__kindof UIView*>*)beforeTo
{
    //: UIView *superConsideredView;
    UIView *superConsideredView;

    //: UIView *textFieldView = _textFieldView;
    UIView *textFieldView = _textFieldView;

    //If find any consider responderView in it's upper hierarchy then will get deepResponderView.
    //: for (Class consideredClass in _toolbarPreviousNextAllowedClasses)
    for (Class consideredClass in _toolbarPreviousNextAllowedClasses)
    {
        //: superConsideredView = [textFieldView superviewOfClassType:consideredClass];
        superConsideredView = [textFieldView down:consideredClass];
	[self setPrimary:_toolbarDoneBarButtonItemAccessibilityLabel];

        //: if (superConsideredView)
        if (superConsideredView)
            //: break;
            break;
    }

    //If there is a superConsideredView in view's hierarchy, then fetching all it's subview that responds. No sorting for superConsideredView, it's by subView position.    (Enhancement ID: #22)
    //: if (superConsideredView)
    if (superConsideredView)
    {
        //: return [superConsideredView deepResponderViews];
        return [superConsideredView deepResponderViews];
    }
    //Otherwise fetching all the siblings
    //: else
    else
    {
        //: NSArray<UIView*> *textFields = [textFieldView responderSiblings];
        NSArray<UIView*> *textFields = [textFieldView responderSiblings];

        //Sorting textFields according to behavior
        //: switch (_toolbarManageBehavior)
        switch (_fireside)
        {
                //If autoToolbar behavior is bySubviews, then returning it.
            //: case IQAutoToolbarBySubviews:
            case IQAutoToolbarBySubviews:
                //: return textFields;
                return textFields;
                //: break;
                break;

                //If autoToolbar behavior is by tag, then sorting it according to tag property.
            //: case IQAutoToolbarByTag:
            case IQAutoToolbarByTag:
                //: return [textFields sortedArrayByTag];
                return [textFields sortedArrayByTag];
                //: break;
                break;

                //If autoToolbar behavior is by tag, then sorting it according to tag property.
            //: case IQAutoToolbarByPosition:
            case IQAutoToolbarByPosition:
                //: return [textFields sortedArrayByPosition];
                return [textFields sortedArrayByPosition];
                //: break;
                break;
            //: default:
            default:
                //: return nil;
                return nil;
                //: break;
                break;
        }
    }
}

/** Returns YES if can navigate to previous responder textField/textView, otherwise NO. */
//: -(BOOL)canGoPrevious
-(BOOL)canGoPrevious
{
    //Getting all responder view's.
    //: NSArray<UIView*> *textFields = [self responderViews];
    NSArray<UIView*> *textFields = [self beforeTo];

    //Getting index of current textField.
    //: NSUInteger index = [textFields indexOfObject:_textFieldView];
    NSUInteger index = [textFields indexOfObject:_textFieldView];

    //If it is not first textField. then it's previous object can becomeFirstResponder.
    //: if (index != NSNotFound &&
    if (index != NSNotFound &&
        //: index > 0)
        index > 0)
    {
        //: return YES;
        return YES;
    }
    //: else
    else
    {
        //: return NO;
        return NO;
    }
}


//: #pragma mark - Customized textField/textView support.
#pragma mark - Customized textField/textView support.

/**
 Add customized Notification for third party customized TextField/TextView.
 */
//: -(void)registerTextFieldViewClass:(nonnull Class)aClass
-(void)characterTitle:(nonnull Class)aClass
  //: didBeginEditingNotificationName:(nonnull NSString *)didBeginEditingNotificationName
  me:(nonnull NSString *)didBeginEditingNotificationName
    //: didEndEditingNotificationName:(nonnull NSString *)didEndEditingNotificationName
    clip:(nonnull NSString *)didEndEditingNotificationName
{
    //: [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textFieldViewDidBeginEditing:) name:didBeginEditingNotificationName object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(need:) name:didBeginEditingNotificationName object:nil];
    //: [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textFieldViewDidEndEditing:) name:didEndEditingNotificationName object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(ended:) name:didEndEditingNotificationName object:nil];
}

- (void)setSpecialController:(UIViewController *)specialController {
    //: OC_CUSTOM_PROPERTY_INJECT
    _specialController = specialController;
}


/** Resigning textField. */
//: - (BOOL)resignFirstResponder
- (BOOL)formatResponder
{
    //: UIView *textFieldView = _textFieldView;
    UIView *textFieldView = _textFieldView;

    //: if (textFieldView)
    if (textFieldView)
    {
        //  Retaining textFieldView
        //: UIView *textFieldRetain = textFieldView;
        UIView *textFieldRetain = textFieldView;

        //Resigning first responder
        //: BOOL isResignFirstResponder = [textFieldView resignFirstResponder];
        BOOL isResignFirstResponder = [textFieldView resignFirstResponder];

        //  If it refuses then becoming it as first responder again.    (Bug ID: #96)
        //: if (isResignFirstResponder == NO)
        if (isResignFirstResponder == NO)
        {
            //If it refuses to resign then becoming it first responder again for getting notifications callback.
            //: [textFieldRetain becomeFirstResponder];
            [textFieldRetain becomeFirstResponder];

            //: [self showLog:[NSString stringWithFormat:@"Refuses to Resign first responder: %@",textFieldView]];
            [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData viewKeepId],textFieldView]];
        }

        //: return isResignFirstResponder;
        return isResignFirstResponder;
    }
    //: else
    else
    {
        //: return NO;
        return NO;
    }
}

/** Navigate to previous responder textField/textView.  */
//: -(BOOL)goPrevious
-(BOOL)gen
{
    //Getting all responder view's.
    //: NSArray<__kindof UIView*> *textFields = [self responderViews];
    NSArray<__kindof UIView*> *textFields = [self beforeTo];

    //Getting index of current textField.
    //: NSUInteger index = [textFields indexOfObject:_textFieldView];
    NSUInteger index = [textFields indexOfObject:_textFieldView];

    //If it is not first textField. then it's previous object becomeFirstResponder.
    //: if (index != NSNotFound &&
    if (index != NSNotFound &&
        //: index > 0)
        index > 0)
    {
        //: UITextField *nextTextField = textFields[index-1];
        UITextField *nextTextField = textFields[index-1];

        //: BOOL isAcceptAsFirstResponder = [nextTextField becomeFirstResponder];
        BOOL isAcceptAsFirstResponder = [nextTextField becomeFirstResponder];

        //  If it refuses then becoming previous textFieldView as first responder again.    (Bug ID: #96)
        //: if (isAcceptAsFirstResponder == NO)
        if (isAcceptAsFirstResponder == NO)
        {
            //: [self showLog:[NSString stringWithFormat:@"Refuses to become first responder: %@",nextTextField]];
            [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData coreCurateError],nextTextField]];
        }

        //: return isAcceptAsFirstResponder;
        return isAcceptAsFirstResponder;
    }
    //: else
    else
    {
        //: return NO;
        return NO;
    }
}


/**    nextAction. */
//: -(void)nextAction:(IQBarButtonItem*)barButton
-(void)coverred:(SandMinimalButtonItem*)barButton
{
    //If user wants to play input Click sound. Then Play Input Click Sound.
    //: if (_shouldPlayInputClicks)
    if (_my)
    {
        //: [[UIDevice currentDevice] playInputClick];
        [[UIDevice currentDevice] playInputClick];
    }

    //: if ([self canGoNext])
    if ([self canGoNext])
    {
        //: UIView *currentTextFieldView = _textFieldView;
        UIView *currentTextFieldView = _textFieldView;
        //: BOOL isAcceptAsFirstResponder = [self goNext];
        BOOL isAcceptAsFirstResponder = [self burn];

        //: NSInvocation *invocation = barButton.invocation;
        NSInvocation *invocation = barButton.invocation;
        //: UIView *sender = currentTextFieldView;
        UIView *sender = currentTextFieldView;

        //Handling search bar special case
        {
            //: UISearchBar *searchBar = currentTextFieldView.textFieldSearchBar;
            UISearchBar *searchBar = currentTextFieldView.textFieldSearchBar;

            //: if (searchBar)
            if (searchBar)
            {
                //: invocation = searchBar.keyboardToolbar.nextBarButton.invocation;
                invocation = searchBar.keyboardToolbar.nextBarButton.invocation;
	[self setCorrect:_operation];
                //: sender = searchBar;
                sender = searchBar;
            }
        }

        //: if (isAcceptAsFirstResponder == YES && invocation)
        if (isAcceptAsFirstResponder == YES && invocation)
        {
            //: if (invocation.methodSignature.numberOfArguments > 2)
            if (invocation.methodSignature.numberOfArguments > 2)
            {
                //: [invocation setArgument:&sender atIndex:2];
                [invocation setArgument:&sender atIndex:2];
            }

            //: [invocation invoke];
            [invocation invoke];
        }
    }
}

/*  UIKeyboardWillHideNotification. So setting rootViewController to it's default frame. */
//: - (void)keyboardWillHide:(NSNotification*)aNotification
- (void)afterGravity:(NSNotification*)aNotification
{
    //If it's not a fake notification generated by [self setEnable:NO].
    //: if (aNotification) _kbShowNotification = nil;
    if (aNotification) _preexist = nil;

    //  Boolean to know keyboard is showing/hiding
    //: _keyboardShowing = NO;
    _keyboardShowing = NO;

    //  Getting keyboard animation duration
    //: CGFloat duration = [[aNotification userInfo][UIKeyboardAnimationDurationUserInfoKey] floatValue];
    CGFloat duration = [[aNotification userInfo][UIKeyboardAnimationDurationUserInfoKey] floatValue];
    //: if (duration!= 0.0f)
    if (duration!= 0.0f)
    {
        //: _animationDuration = duration;
        _animationDuration = duration;
	[self setArea:_topViewBeginSafeAreaInsets];
    }
    //: else
    else
    {
        //: _animationDuration = 0.25;
        _animationDuration = 0.25;
	[self setSortActive:_rootViewControllerWhilePopGestureRecognizerActive];
    }

    //If not enabled then do nothing.
    //: if ([self privateIsEnabled] == NO) return;
    if ([self representationOffd] == NO) return;

    //: CFTimeInterval startTime = CACurrentMediaTime();
    CFTimeInterval startTime = CACurrentMediaTime();
    //: [self showLog:[NSString stringWithFormat:@">>>>> %@ started >>>>>",NSStringFromSelector(_cmd)] indentation:1];
    [self take:[NSString stringWithFormat:[MassiveEmergencyData componentPublisherPlatform],NSStringFromSelector(_cmd)] message:1];

    //: [self showLog:[NSString stringWithFormat:@"Notification Object: %@", NSStringFromClass([aNotification.object class])]];
    [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData commonTradeValue], NSStringFromClass([aNotification.object class])]];

    //Commented due to #56. Added all the conditions below to handle WKWebView's textFields.    (Bug ID: #56)
    //  We are unable to get textField object while keyboard showing on WKWebView's textField.  (Bug ID: #11)
//    if (_textFieldView == nil)   return;

    //Restoring the contentOffset of the lastScrollView
    //: __strong __typeof__(UIScrollView) *strongLastScrollView = _lastScrollView;
    __strong __typeof__(UIScrollView) *strongLastScrollView = _lastScrollView;

    //: if (strongLastScrollView)
    if (strongLastScrollView)
    {
        //: __weak __typeof__(self) weakSelf = self;
        __weak __typeof__(self) weakSelf = self;
        //: __weak __typeof__(UIView) *weakTextFieldView = self.textFieldView;
        __weak __typeof__(UIView) *weakTextFieldView = self.textFieldView;

        //: [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{
        [UIView animateWithDuration:_animationDuration delay:0 options:(_animationCurve|UIViewAnimationOptionBeginFromCurrentState) animations:^{

            //: __strong __typeof__(self) strongSelf = weakSelf;
            __strong __typeof__(self) strongSelf = weakSelf;
            //: __strong __typeof__(UIView) *strongTextFieldView = weakTextFieldView;
            __strong __typeof__(UIView) *strongTextFieldView = weakTextFieldView;

            //: if (UIEdgeInsetsEqualToEdgeInsets(strongLastScrollView.contentInset, strongSelf.startingContentInsets) == NO)
            if (UIEdgeInsetsEqualToEdgeInsets(strongLastScrollView.contentInset, strongSelf.startingContentInsets) == NO)
            {
                //: [strongSelf showLog:[NSString stringWithFormat:@"Restoring ScrollView contentInset to : %@",NSStringFromUIEdgeInsets(strongSelf.startingContentInsets)]];
                [strongSelf prepareLog:[NSString stringWithFormat:[MassiveEmergencyData themeGiNearlyTimer],NSStringFromUIEdgeInsets(strongSelf.startingContentInsets)]];

                //: strongLastScrollView.contentInset = strongSelf.startingContentInsets;
                strongLastScrollView.contentInset = strongSelf.startingContentInsets;
                //: strongLastScrollView.scrollIndicatorInsets = strongSelf.startingScrollIndicatorInsets;
                strongLastScrollView.scrollIndicatorInsets = [self selectStarting:strongSelf.startingScrollIndicatorInsets];
            }

            //: if (strongLastScrollView.shouldRestoreScrollViewContentOffset && __CGPointEqualToPoint(strongLastScrollView.contentOffset, strongSelf.startingContentOffset) == NO)
            if (strongLastScrollView.shouldRestoreScrollViewContentOffset && __CGPointEqualToPoint(strongLastScrollView.contentOffset, strongSelf.startingContentOffset) == NO)
            {
                //: [strongSelf showLog:[NSString stringWithFormat:@"Restoring ScrollView contentOffset to : %@",NSStringFromCGPoint(strongSelf.startingContentOffset)]];
                [strongSelf prepareLog:[NSString stringWithFormat:[MassiveEmergencyData appDiabetesSettings],NSStringFromCGPoint(strongSelf.startingContentOffset)]];

                //  (Bug ID: #1365, #1508, #1541)
                //: UIStackView *stackView = [strongTextFieldView superviewOfClassType:[UIStackView class] belowView:strongLastScrollView];
                UIStackView *stackView = [strongTextFieldView point:[UIStackView class] transform:strongLastScrollView];
                //: BOOL animatedContentOffset = stackView != nil || [strongLastScrollView isKindOfClass:[UICollectionView class]];
                BOOL animatedContentOffset = stackView != nil || [strongLastScrollView isKindOfClass:[UICollectionView class]];

                //: if (animatedContentOffset)
                if (animatedContentOffset)
                {
                    //: [strongLastScrollView setContentOffset:strongSelf.startingContentOffset animated:UIView.areAnimationsEnabled];
                    [strongLastScrollView setContentOffset:strongSelf.startingContentOffset animated:UIView.areAnimationsEnabled];
                }
                //: else
                else
                {
                    //: strongLastScrollView.contentOffset = strongSelf.startingContentOffset;
                    strongLastScrollView.contentOffset = strongSelf.startingContentOffset;
                }
            }

            // TODO: restore scrollView state
            // This is temporary solution. Have to implement the save and restore scrollView state
            //: UIScrollView *superScrollView = strongLastScrollView;
            UIScrollView *superScrollView = strongLastScrollView;
            //: do
            do
            {
                //: CGSize contentSize = CGSizeMake(((superScrollView.contentSize.width) > (CGRectGetWidth(superScrollView.frame)) ? (superScrollView.contentSize.width) : (CGRectGetWidth(superScrollView.frame))), ((superScrollView.contentSize.height) > (CGRectGetHeight(superScrollView.frame)) ? (superScrollView.contentSize.height) : (CGRectGetHeight(superScrollView.frame))));
                CGSize contentSize = CGSizeMake(((superScrollView.contentSize.width) > (CGRectGetWidth(superScrollView.frame)) ? (superScrollView.contentSize.width) : (CGRectGetWidth(superScrollView.frame))), ((superScrollView.contentSize.height) > (CGRectGetHeight(superScrollView.frame)) ? (superScrollView.contentSize.height) : (CGRectGetHeight(superScrollView.frame))));

                //: CGFloat minimumY = contentSize.height-CGRectGetHeight(superScrollView.frame);
                CGFloat minimumY = contentSize.height-CGRectGetHeight(superScrollView.frame);

                //: if (minimumY<superScrollView.contentOffset.y)
                if (minimumY<superScrollView.contentOffset.y)
                {
                    //: CGPoint newContentOffset = CGPointMake(superScrollView.contentOffset.x, minimumY);
                    CGPoint newContentOffset = CGPointMake(superScrollView.contentOffset.x, minimumY);
                    //: if (__CGPointEqualToPoint(superScrollView.contentOffset, newContentOffset) == NO)
                    if (__CGPointEqualToPoint(superScrollView.contentOffset, newContentOffset) == NO)
                    {
                        //: [self showLog:[NSString stringWithFormat:@"Restoring contentOffset to : %@",NSStringFromCGPoint(newContentOffset)]];
                        [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData themeIdentifyId],NSStringFromCGPoint(newContentOffset)]];

                        //  (Bug ID: #1365, #1508, #1541)
                        //: UIStackView *stackView = [strongSelf.textFieldView superviewOfClassType:[UIStackView class] belowView:superScrollView];
                        UIStackView *stackView = [strongSelf.textFieldView point:[UIStackView class] transform:superScrollView];
                        //: BOOL animatedContentOffset = stackView != nil || [superScrollView isKindOfClass:[UICollectionView class]];
                        BOOL animatedContentOffset = stackView != nil || [superScrollView isKindOfClass:[UICollectionView class]];

                        //: if (animatedContentOffset)
                        if (animatedContentOffset)
                        {
                            //: [superScrollView setContentOffset:newContentOffset animated:UIView.areAnimationsEnabled];
                            [superScrollView setContentOffset:newContentOffset animated:UIView.areAnimationsEnabled];
                        }
                        //: else
                        else
                        {
                            //: superScrollView.contentOffset = newContentOffset;
                            superScrollView.contentOffset = newContentOffset;
                        }
                    }
                }
            }
            //: while ((superScrollView = (UIScrollView*)[superScrollView superviewOfClassType:[UIScrollView class]]));
            while ((superScrollView = (UIScrollView*)[superScrollView down:[UIScrollView class]]));

        //: } completion:NULL];
        } completion:NULL];
    }

    //: [self restorePosition];
    [self juxtaposition];

    //Reset all values
    //: _lastScrollView = nil;
    _lastScrollView = nil;
	[self setCorrect:_operation];
    //: _kbFrame = CGRectZero;
    _schemeFrame = CGRectZero;
    //: [self notifyKeyboardSize:_kbFrame.size];
    [self top:_schemeFrame.size];
    //: _startingContentInsets = UIEdgeInsetsZero;
    _startingContentInsets = UIEdgeInsetsZero;
    //: _startingScrollIndicatorInsets = UIEdgeInsetsZero;
    _startingScrollIndicatorInsets = UIEdgeInsetsZero;
    //: _startingContentOffset = CGPointZero;
    _startingContentOffset = CGPointZero;
	[self setSpecialController:_rootViewController];
    //: _topViewBeginOrigin = CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308);
    _topViewBeginOrigin = CGPointMake(1.7976931348623157e+308, 1.7976931348623157e+308);
	[self setSortActive:_rootViewControllerWhilePopGestureRecognizerActive];
    //: _topViewBeginSafeAreaInsets = UIEdgeInsetsZero;
    _topViewBeginSafeAreaInsets = UIEdgeInsetsZero;

    //: CFTimeInterval elapsedTime = CACurrentMediaTime() - startTime;
    CFTimeInterval elapsedTime = CACurrentMediaTime() - startTime;
    //: [self showLog:[NSString stringWithFormat:@"<<<<< %@ ended: %g seconds <<<<<",NSStringFromSelector(_cmd),elapsedTime] indentation:-1];
    [self take:[NSString stringWithFormat:[MassiveEmergencyData styleWayPlatform],NSStringFromSelector(_cmd),elapsedTime] message:-1];
}


/** Navigate to next responder textField/textView.  */
//: -(BOOL)goNext
-(BOOL)burn
{
    //Getting all responder view's.
    //: NSArray<__kindof UIView*> *textFields = [self responderViews];
    NSArray<__kindof UIView*> *textFields = [self beforeTo];

    //Getting index of current textField.
    //: NSUInteger index = [textFields indexOfObject:_textFieldView];
    NSUInteger index = [textFields indexOfObject:_textFieldView];

    //If it is not last textField. then it's next object becomeFirstResponder.
    //: if (index != NSNotFound &&
    if (index != NSNotFound &&
        //: index < textFields.count-1)
        index < textFields.count-1)
    {
        //: UITextField *nextTextField = textFields[index+1];
        UITextField *nextTextField = textFields[index+1];

        //: BOOL isAcceptAsFirstResponder = [nextTextField becomeFirstResponder];
        BOOL isAcceptAsFirstResponder = [nextTextField becomeFirstResponder];

        //  If it refuses then becoming previous textFieldView as first responder again.    (Bug ID: #96)
        //: if (isAcceptAsFirstResponder == NO)
        if (isAcceptAsFirstResponder == NO)
        {
            //: [self showLog:[NSString stringWithFormat:@"Refuses to become first responder: %@",nextTextField]];
            [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData coreCurateError],nextTextField]];
        }

        //: return isAcceptAsFirstResponder;
        return isAcceptAsFirstResponder;
    }
    //: else
    else
    {
        //: return NO;
        return NO;
    }
}

- (void)setPrimary:(NSString *)primary {
    //: OC_CUSTOM_PROPERTY_INJECT
    _primary = primary;
}


//: #pragma mark previous/next/done functionality
#pragma mark previous/next/done functionality
/**    previousAction. */
//: -(void)previousAction:(IQBarButtonItem*)barButton
-(void)bubbling:(SandMinimalButtonItem*)barButton
{
    //If user wants to play input Click sound. Then Play Input Click Sound.
    //: if (_shouldPlayInputClicks)
    if (_my)
    {
        //: [[UIDevice currentDevice] playInputClick];
        [[UIDevice currentDevice] playInputClick];
    }

    //: if ([self canGoPrevious])
    if ([self canGoPrevious])
    {
        //: UIView *currentTextFieldView = _textFieldView;
        UIView *currentTextFieldView = _textFieldView;
        //: BOOL isAcceptAsFirstResponder = [self goPrevious];
        BOOL isAcceptAsFirstResponder = [self gen];

        //: NSInvocation *invocation = barButton.invocation;
        NSInvocation *invocation = barButton.invocation;
        //: UIView *sender = currentTextFieldView;
        UIView *sender = currentTextFieldView;

        //Handling search bar special case
        {
            //: UISearchBar *searchBar = currentTextFieldView.textFieldSearchBar;
            UISearchBar *searchBar = currentTextFieldView.textFieldSearchBar;

            //: if (searchBar)
            if (searchBar)
            {
                //: invocation = searchBar.keyboardToolbar.previousBarButton.invocation;
                invocation = searchBar.keyboardToolbar.previousBarButton.invocation;
	[self setArea:_topViewBeginSafeAreaInsets];
                //: sender = searchBar;
                sender = searchBar;
            }
        }

        //: if (isAcceptAsFirstResponder == YES && invocation)
        if (isAcceptAsFirstResponder == YES && invocation)
        {
            //: if (invocation.methodSignature.numberOfArguments > 2)
            if (invocation.methodSignature.numberOfArguments > 2)
            {
                //: [invocation setArgument:&sender atIndex:2];
                [invocation setArgument:&sender atIndex:2];
            }

            //: [invocation invoke];
            [invocation invoke];
        }
    }
}

//	Setting keyboard distance from text field.
//: -(void)setKeyboardDistanceFromTextField:(CGFloat)keyboardDistanceFromTextField
-(void)setKeyboardDistanceFromTextField:(CGFloat)keyboardDistanceFromTextField
{
    //Can't be less than zero. Minimum is zero.
 //: _keyboardDistanceFromTextField = ((keyboardDistanceFromTextField) > (0) ? (keyboardDistanceFromTextField) : (0));
 _viewerMedia = ((keyboardDistanceFromTextField) > (0) ? (keyboardDistanceFromTextField) : (0));
	[self setStarting:_startingScrollIndicatorInsets];

    //: [self showLog:[NSString stringWithFormat:@"keyboardDistanceFromTextField: %.2f",_keyboardDistanceFromTextField]];
    [self prepareLog:[NSString stringWithFormat:[MassiveEmergencyData screenProceedMartId],_viewerMedia]];
}


@end